{
  "version": 3,
  "sources": ["../src/Fisiks2DVector.ts", "../src/FisiksAABB.ts", "../src/FisiksShape.ts", "../src/FisiksTransform.ts", "../src/utils/utils.ts", "../src/FisiksBody.ts", "../src/FisiksBodyController.ts", "../src/FisiksCollisions.ts", "../src/FisiksCollisionManifold.ts", "../src/FisiksDisplay.ts", "../src/FisiksObservers.ts"],
  "sourcesContent": ["import { FisiksTransform } from \"./FisiksTransform\";\r\n\r\nexport class Fisiks2DVector {\r\n    public readonly x: number;\r\n    public readonly y: number;\r\n    \r\n    public static readonly Zero: Fisiks2DVector = new Fisiks2DVector(0, 0); \r\n\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public static Add(addent: Fisiks2DVector, otherAddent: Fisiks2DVector): Fisiks2DVector {\r\n        return new Fisiks2DVector(addent.x + otherAddent.x, addent.y + otherAddent.y); \r\n    }\r\n\r\n    public static Difference(minuend: Fisiks2DVector, subtrahend: Fisiks2DVector): Fisiks2DVector {\r\n        return new Fisiks2DVector(minuend.x - subtrahend.x, minuend.y - subtrahend.y);\r\n    }\r\n\r\n    public static ScalarMultiplication(scalar: number, vector: Fisiks2DVector) {\r\n        return new Fisiks2DVector(scalar * vector.x, scalar * vector.y);\r\n    }\r\n\r\n    public static Normalize(vector: Fisiks2DVector): Fisiks2DVector {\r\n        const magnitude: number = vector.GetMagnitude();\r\n        return new Fisiks2DVector(vector.x / magnitude, vector.y / magnitude);\r\n    }\r\n\r\n    public static Distance(vector: Fisiks2DVector, otherVector: Fisiks2DVector): number {\r\n        const dx: number = otherVector.x - vector.x;\r\n        const dy: number = otherVector.y - vector.y; \r\n\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    public static SquaredDistance(vector: Fisiks2DVector, otherVector: Fisiks2DVector): number {\r\n        const dx: number = otherVector.x - vector.x;\r\n        const dy: number = otherVector.y - vector.y; \r\n\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n    public static Transform(vector: Fisiks2DVector, transform: FisiksTransform): Fisiks2DVector {\r\n        const relativeVector = new Fisiks2DVector(\r\n            vector.x - transform.positionX,\r\n            vector.y - transform.positionY\r\n        );\r\n\r\n        const rotationVector = new Fisiks2DVector(\r\n            transform.cos * relativeVector.x - transform.sin * relativeVector.y,\r\n            transform.sin * relativeVector.x + transform.cos * relativeVector.y\r\n        )\r\n\r\n        return new Fisiks2DVector(rotationVector.x + transform.positionX, rotationVector.y + transform.positionY);\r\n    } \r\n\r\n    public static DotProduct(vector: Fisiks2DVector, otherVector: Fisiks2DVector): number {\r\n        return vector.x * otherVector.x + vector.y * otherVector.y;\r\n    }\r\n\r\n    public static CrossProduct(vector: Fisiks2DVector, otherVector: Fisiks2DVector): number {\r\n        return vector.x * otherVector.y - vector.y * otherVector.x;\r\n    }\r\n\r\n    public GetMagnitude(): number {\r\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\r\n    }\r\n\r\n    public GetSquaredMagnitude(): number {\r\n        return (this.x * this.x) + (this.y * this.y);\r\n    }\r\n\r\n    public AreEquals(otherVector: Fisiks2DVector): boolean {\r\n        return (this.x === otherVector.x) && (this.y === otherVector.y);\r\n    };\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\n\r\nexport class FisiksAxisAlignedBoundingBox {\r\n    public readonly min: Fisiks2DVector;\r\n    public readonly max: Fisiks2DVector;\r\n\r\n    constructor(min: Fisiks2DVector, max: Fisiks2DVector){\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksAxisAlignedBoundingBox } from \"./FisiksAABB\";\r\n\r\nexport enum ShapeType { Box, Circle};  \r\n\r\nexport class FisiksShape {\r\n    public static DrawCircle(context: CanvasRenderingContext2D, position: Fisiks2DVector, color: string, radius: number): void{\r\n        context.beginPath();\r\n        context.arc(position.x, position.y, radius, 0, 2 * Math.PI);\r\n        context.fillStyle = color;\r\n        context.fill();    \r\n    }\r\n\r\n    public static DrawBox(context: CanvasRenderingContext2D, position: Fisiks2DVector, color: string, width: number, height: number): void{\r\n        context.beginPath();\r\n        context.rect(position.x, position.y, width, height);\r\n        context.fillStyle = color;\r\n        context.fill();\r\n    }\r\n\r\n    public static DrawVertices(context: CanvasRenderingContext2D, vertices: Fisiks2DVector[], color: string, AABB: FisiksAxisAlignedBoundingBox){\r\n        for (const vertex of vertices) {\r\n            context.beginPath();\r\n            context.arc(vertex.x, vertex.y, 3, 0, 2 * Math.PI);\r\n            context.fillStyle = color;\r\n            context.fill();  \r\n        }\r\n\r\n        let AABBVertices: Fisiks2DVector[] = [AABB.max, AABB.min]\r\n        \r\n        for (const vertex of AABBVertices) {\r\n            context.beginPath();\r\n            context.arc(vertex.x, vertex.y, 3, 0, 2 * Math.PI);\r\n            context.fillStyle = 'orange';\r\n            context.fill();\r\n        }\r\n    }\r\n\r\n    public static DrawPoints(context: CanvasRenderingContext2D, points: Fisiks2DVector[]){\r\n        for (const point of points) {\r\n            context.beginPath();\r\n            context.arc(point.x, point.y, 3, 0, 2 * Math.PI);\r\n            context.fillStyle = 'green';\r\n            context.fill();  \r\n        }\r\n    }\r\n\r\n    public static DrawAxis(context: CanvasRenderingContext2D, axis: Fisiks2DVector, position: Fisiks2DVector): void {\r\n        context.beginPath();\r\n        context.moveTo(position.x, position.y);\r\n        context.lineTo(position.x + axis.x * 50, position.y + axis.y * 50);\r\n        context.strokeStyle = 'red'; \r\n        context.lineWidth = 2;\r\n        context.stroke();\r\n    }\r\n    \r\n    public static DrawPolygon(context: CanvasRenderingContext2D, vertices: Fisiks2DVector[], color: string ): void {\r\n        \r\n        if (vertices.length < 3) {\r\n            throw new Error(\"A polygon needs at least three vertices.\");\r\n        }\r\n    \r\n        context.beginPath();\r\n        context.moveTo(vertices[0].x, vertices[0].y);\r\n    \r\n        for (let i = 1; i < vertices.length; i++) {\r\n            context.lineTo(vertices[i].x, vertices[i].y);\r\n        }\r\n    \r\n        context.closePath();\r\n        context.fillStyle = color;\r\n        context.fill();\r\n    }\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\n\r\nexport class FisiksTransform {\r\n    public readonly positionX: number;\r\n    public readonly positionY: number;\r\n    public readonly sin: number;\r\n    public readonly cos: number;\r\n\r\n    constructor(position: Fisiks2DVector, angle: number){\r\n        this.positionX = position.x;\r\n        this.positionY = position.y;\r\n        this.sin = Math.sin(angle);\r\n        this.cos = Math.cos(angle);\r\n    }\r\n\r\n    public static readonly Zero: FisiksTransform = new FisiksTransform(Fisiks2DVector.Zero, 0);\r\n}", "import { Fisiks2DVector } from \"../Fisiks2DVector\";\r\n\r\nexport type id = `${string}-${string}-${string}-${string}`\r\n\r\nexport function generateId(): id {\r\n    const segment = () => Math.random().toString(36).substring(2, 6); \r\n    return `${segment()}-${segment()}-${segment()}-${segment()}` as id;\r\n}\r\n\r\nexport class Segment {\r\n    readonly pointA: Fisiks2DVector;\r\n    readonly pointB: Fisiks2DVector;\r\n\r\n    constructor(pointA: Fisiks2DVector, pointB: Fisiks2DVector){\r\n        this.pointA = pointA;\r\n        this.pointB = pointB;\r\n    }\r\n\r\n    getDistance(): Fisiks2DVector {\r\n        const distance: Fisiks2DVector = Fisiks2DVector.Difference(this.pointA, this.pointB); \r\n        return distance;\r\n    }\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksAxisAlignedBoundingBox } from \"./FisiksAABB\";\r\nimport { FisiksShape } from \"./FisiksShape\";\r\nimport { FisiksTransform } from \"./FisiksTransform\";\r\nimport { generateId, id } from \"./utils/utils\";\r\n\r\nexport class FisiksBody {\r\n    private readonly id: id = generateId(); \r\n    private readonly context: CanvasRenderingContext2D | null;\r\n\r\n    private previousPosition: Fisiks2DVector = Fisiks2DVector.Zero;\r\n    private position: Fisiks2DVector;\r\n    \r\n    private center: Fisiks2DVector = Fisiks2DVector.Zero;\r\n    private color: string = 'white';\r\n\r\n    private linearVelocity: Fisiks2DVector = Fisiks2DVector.Zero;\r\n    private previousVelocity: Fisiks2DVector = Fisiks2DVector.Zero;\r\n\r\n    private previousRotation: number = 0;\r\n    private rotationalVelocity: Fisiks2DVector = Fisiks2DVector.Zero;\r\n\r\n    private angle: number = 0;\r\n    private angularVelocity: number = 0;\r\n\r\n    private inertia: number = 0;\r\n    private force: Fisiks2DVector = Fisiks2DVector.Zero;\r\n    private isColliding: boolean = false;\r\n\r\n    private area: number = 0;\r\n    private density: number = 0;\r\n    private mass: number = 0;\r\n    private restitution: number = 0.5;\r\n\r\n    private isStatic: boolean = false;\r\n\r\n    constructor(context: CanvasRenderingContext2D | null, position: Fisiks2DVector){\r\n        this.context = context;\r\n        this.position = position;\r\n    }\r\n\r\n    setPreviousVelocity(velocity: Fisiks2DVector){\r\n        this.previousVelocity = velocity;\r\n    }\r\n\r\n    getPreviousVelocity(){\r\n        return this.previousVelocity\r\n    }\r\n\r\n    setPreviousPosition(position: Fisiks2DVector){\r\n        this.previousPosition = position;\r\n    }\r\n\r\n    getPreviousPosition(){\r\n        return this.previousPosition\r\n    }\r\n\r\n    setPreviousRotation(amount: number){\r\n        this.previousRotation = amount;\r\n    }\r\n\r\n    getPreviousRotation(){\r\n        return this.previousRotation;\r\n    }\r\n\r\n    getId(){\r\n        return this.id;\r\n    }\r\n\r\n    getContext(){\r\n        return this.context;\r\n    }\r\n    \r\n    setPosition(position: Fisiks2DVector){\r\n        this.position = position;\r\n    }\r\n\r\n    getPosition(){\r\n        return this.position\r\n    }\r\n\r\n    setCenter(center: Fisiks2DVector){\r\n        this.center = center;\r\n    }\r\n\r\n    getCenter(){\r\n        return this.center;\r\n    }\r\n\r\n    setColor(color: string){\r\n        this.color = color;\r\n    }\r\n\r\n    getColor(){\r\n        return this.color;\r\n    }\r\n\r\n    setArea(area: number){\r\n        this.area = area;\r\n    }\r\n\r\n    setMass(mass: number){\r\n        this.mass = mass;\r\n    }\r\n\r\n    getMass(){\r\n        return this.mass\r\n    }\r\n\r\n    setDensity(density: number){\r\n        this.density = density;\r\n    }\r\n\r\n    setRestitution(restitution: number){\r\n        this.restitution = restitution; \r\n    }\r\n\r\n    getRestitution(){\r\n        return this.restitution;\r\n    }\r\n\r\n    setStatic(condition: boolean){\r\n        this.isStatic = condition;\r\n    }\r\n\r\n    getStatic(){\r\n        return this.isStatic;\r\n    }\r\n\r\n    setInertia(inertia: number){\r\n        this.inertia = inertia;\r\n    }\r\n\r\n    getInertia(){\r\n        return this.inertia;\r\n    }\r\n\r\n    setLinearVelocity(linearVelocity: Fisiks2DVector){\r\n        this.linearVelocity = linearVelocity;\r\n    }\r\n\r\n    getLinearVelocity(){\r\n        return this.linearVelocity\r\n    }\r\n\r\n    setRotationalVelocity(rotationalVelocity: number){\r\n        this.rotationalVelocity = this.rotationalVelocity;\r\n    }\r\n\r\n    getRotationalVelocity(){\r\n        return this.rotationalVelocity;\r\n    }\r\n\r\n    setAngularVelocity(angularVelocity: number){\r\n        this.angularVelocity = angularVelocity;\r\n    }\r\n\r\n    getAngularVelocity(){\r\n        return this.angularVelocity;\r\n    }\r\n\r\n    setAngle(angle: number){\r\n        this.angle = angle;\r\n    }\r\n\r\n    getAngle(){\r\n        return this.angle\r\n    }\r\n\r\n    setForce(amount: Fisiks2DVector){\r\n        this.force = amount;\r\n    }\r\n\r\n    getForce(){\r\n        return this.force\r\n    }\r\n\r\n    Rotate(amount: number){};\r\n    Draw(){};\r\n    Step(time: number, gravity: Fisiks2DVector){};\r\n    Move(amount: Fisiks2DVector){};\r\n    MoveTo(position: Fisiks2DVector){};\r\n    drawVertices(){};\r\n    drawAABB(){};\r\n\r\n    getAABB(): FisiksAxisAlignedBoundingBox | Error {\r\n        return new Error('Not init.')\r\n    }\r\n\r\n    ApplyForce(amount: Fisiks2DVector): void{\r\n        this.force = amount;\r\n    }\r\n\r\n}\r\n\r\nexport class FisiksBodyCircle extends FisiksBody {\r\n    private radius: number; \r\n\r\n    constructor(context: CanvasRenderingContext2D | null, position: Fisiks2DVector, radius: number){\r\n        super(context, position)\r\n        this.radius = radius;\r\n\r\n        const AREA_MASS_DENSITY: number = Math.PI * Math.pow(radius, 2);\r\n        const INERTIA = 0.5 * AREA_MASS_DENSITY * Math.pow(this.radius, 2);\r\n\r\n        this.setCenter(position);\r\n        this.setArea(AREA_MASS_DENSITY);\r\n        this.setDensity(AREA_MASS_DENSITY);\r\n        this.setMass(AREA_MASS_DENSITY);\r\n        this.setInertia(INERTIA);\r\n    }\r\n\r\n    override setPosition(position: Fisiks2DVector){\r\n        super.setPosition(position);\r\n        this.setCenter(position);\r\n    }\r\n    \r\n    getRadius(){\r\n        return this.radius;\r\n    }\r\n\r\n    override Draw(){\r\n        const context = this.getContext();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawCircle(context, this.getPosition(), this.getColor(), this.radius);\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    override drawVertices(){\r\n        const context = super.getContext();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawPoints(context, [this.getPosition()]);\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    override drawAABB(){\r\n        const context = this.getContext();\r\n        const AABB = this.getAABB();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawPoints(context, [AABB.min, AABB.max]);\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    getAABB(){\r\n        let max: Fisiks2DVector = new Fisiks2DVector(Number.MIN_VALUE, Number.MIN_VALUE); \r\n        let min: Fisiks2DVector = new Fisiks2DVector(Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n        min = new Fisiks2DVector(\r\n            this.getCenter().x - this.radius, \r\n            this.getCenter().y - this.radius\r\n        );\r\n\r\n        max = new Fisiks2DVector(\r\n            this.getCenter().x + this.radius,\r\n            this.getCenter().y + this.radius\r\n        )\r\n\r\n        return new FisiksAxisAlignedBoundingBox(min, max);\r\n    }\r\n\r\n    override MoveTo(position: Fisiks2DVector){\r\n        this.setPosition(position);\r\n        this.setCenter(position); \r\n    }\r\n\r\n    override Move(amount: Fisiks2DVector): void {\r\n        const newPosition = Fisiks2DVector.Add(this.getPosition(), amount);\r\n        this.setPosition(newPosition);\r\n\r\n        const newCenter = Fisiks2DVector.Add(this.getCenter(), amount)\r\n        this.setCenter(newCenter);\r\n    }\r\n\r\n    override Step(time: number, gravity: Fisiks2DVector): void {\r\n        if (this.getStatic()) return; \r\n        if (this.getMass() === 0) return;\r\n    \r\n        const gravityEffect = Fisiks2DVector.ScalarMultiplication(time, gravity);\r\n        const newLinearVelocity = Fisiks2DVector.Add(this.getLinearVelocity(), gravityEffect);\r\n        this.setLinearVelocity(newLinearVelocity);\r\n    \r\n        const newPosition = Fisiks2DVector.Add(this.getPosition(), Fisiks2DVector.ScalarMultiplication(time, this.getLinearVelocity()));\r\n        this.setPosition(newPosition);\r\n    \r\n        const newCenter = Fisiks2DVector.Add(this.getCenter(), Fisiks2DVector.ScalarMultiplication(time, this.getLinearVelocity()));\r\n        this.setCenter(newCenter);\r\n    \r\n        const newAngle = this.getAngle() + this.getAngularVelocity() * time;\r\n        this.setAngle(newAngle);\r\n    \r\n        this.setForce(Fisiks2DVector.Zero);\r\n    }\r\n}\r\n\r\nexport class FisiksBodyBox extends FisiksBody {\r\n    private width: number = 100;  \r\n    private height: number = 100; \r\n    private vertices: Fisiks2DVector[] = [];\r\n    private transformedVertices: Fisiks2DVector[] = [];\r\n\r\n    constructor(context: CanvasRenderingContext2D | null, position: Fisiks2DVector, width: number, height: number){\r\n        super(context, position)\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        const CENTER = new Fisiks2DVector(position.x + width/2, position.y + height/2);\r\n        const AREA_MASS_DENSITY: number = width * height;\r\n\r\n        this.setCenter(CENTER);\r\n        this.setArea(AREA_MASS_DENSITY);\r\n        this.setMass(AREA_MASS_DENSITY);\r\n        this.setDensity(AREA_MASS_DENSITY);\r\n\r\n        const INERTIA = (1 / 12) * this.getMass() * (Math.pow(this.height, 2) + Math.pow(this.width, 2))\r\n\r\n        this.setInertia(INERTIA);\r\n\r\n        if(this.transformedVertices.length === 0){\r\n            this.vertices = this.CreateBoxVertices(width, height);\r\n        } else {\r\n            this.vertices = this.transformedVertices;\r\n        }\r\n    }\r\n\r\n    getHeight(){\r\n        return this.height;\r\n    }\r\n\r\n    getWidth(){\r\n        return this.width;\r\n    }\r\n\r\n    getVertices(){\r\n        return this.vertices;\r\n    }\r\n\r\n    override setPosition(position: Fisiks2DVector){\r\n        super.setPosition(position);\r\n\r\n        const newCenter = new Fisiks2DVector(position.x + this.width/2, position.y + this.height/2)\r\n        this.setCenter(newCenter);\r\n\r\n        const newVertices = this.CreateBoxVertices(this.width, this.height);\r\n        this.vertices = newVertices;\r\n    }\r\n\r\n    override Draw(){\r\n        const context = this.getContext();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawPolygon(context, this.vertices, this.getColor());\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    drawVertices(){\r\n        const context = this.getContext();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawPoints(context, this.vertices.concat([this.getCenter()]));\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    override drawAABB(){\r\n        const context = this.getContext();\r\n        const AABB = this.getAABB();\r\n\r\n        if (context instanceof CanvasRenderingContext2D) {\r\n            FisiksShape.DrawPoints(context, [AABB.min, AABB.max]);\r\n        } else {\r\n            throw new Error(\"No context provided.\");\r\n        }\r\n    }\r\n\r\n    getAABB(): FisiksAxisAlignedBoundingBox {\r\n        let max: Fisiks2DVector = new Fisiks2DVector(Number.MIN_VALUE, Number.MIN_VALUE); \r\n        let min: Fisiks2DVector = new Fisiks2DVector(Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n            this.vertices.forEach(vertex => {\r\n                if(vertex.x > max.x){\r\n                    max = new Fisiks2DVector(\r\n                        vertex.x,\r\n                        max.y\r\n                    )\r\n                }\r\n                if(vertex.y > max.y){\r\n                    max = new Fisiks2DVector(\r\n                        max.x,\r\n                        vertex.y\r\n                    )\r\n                }\r\n\r\n                if(vertex.x < min.x){\r\n                    min = new Fisiks2DVector(\r\n                        vertex.x,\r\n                        min.y\r\n                    )\r\n                }\r\n\r\n                if(vertex.y < min.y){\r\n                    min = new Fisiks2DVector(\r\n                        min.x,\r\n                        vertex.y\r\n                    )\r\n                }\r\n            });\r\n\r\n            return new FisiksAxisAlignedBoundingBox(min, max);\r\n    }\r\n\r\n    CreateBoxVertices(width: number, height: number): Fisiks2DVector[]{\r\n        let vertices: Fisiks2DVector[] = [];\r\n        \r\n        let left: number = this.getPosition().x;\r\n        let right: number = this.getPosition().x + width;\r\n        let bottom: number = this.getPosition().y + height;\r\n        let top: number = this.getPosition().y;\r\n\r\n        vertices[0] = new Fisiks2DVector(left, top);\r\n        vertices[1] = new Fisiks2DVector(right, top);\r\n        vertices[2] = new Fisiks2DVector(right, bottom);\r\n        vertices[3] = new Fisiks2DVector(left, bottom);\r\n\r\n        return vertices;\r\n    }\r\n\r\n    GetTranformedVertices(): Fisiks2DVector[] {\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            const vertex: Fisiks2DVector = this.vertices[i];\r\n            const transform: FisiksTransform = new FisiksTransform(this.getCenter(), this.getAngle());\r\n            const rotatedVertex = Fisiks2DVector.Transform(vertex, transform);\r\n            \r\n            this.transformedVertices[i] = rotatedVertex;\r\n        }\r\n    \r\n        return this.transformedVertices;\r\n    }\r\n\r\n    override MoveTo(position: Fisiks2DVector){\r\n        this.setPosition(position);\r\n        \r\n        const newCenter = new Fisiks2DVector(position.x + this.width/2, position.y + this.height/2);\r\n        this.setCenter(newCenter);\r\n\r\n        this.vertices = this.CreateBoxVertices(this.width, this.height)\r\n    }\r\n\r\n    override Move(amount: Fisiks2DVector) {\r\n        const newPosition = Fisiks2DVector.Add(this.getPosition(), amount);\r\n        this.setPosition(newPosition);\r\n\r\n        const newCenter = Fisiks2DVector.Add(this.getCenter(), amount)\r\n        this.setCenter(newCenter);\r\n\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            this.vertices[i] = Fisiks2DVector.Add(this.vertices[i], amount);                \r\n        }\r\n    }\r\n\r\n    override Rotate(amount: number){\r\n        this.setAngle(amount);\r\n        \r\n        const newVertices = this.GetTranformedVertices();\r\n        this.vertices = newVertices;\r\n        \r\n        this.setAngle(0);\r\n    }\r\n\r\n    override Step(time: number, gravity: Fisiks2DVector): void {\r\n        if (this.getStatic()) return; // No afecta cuerpos est\u00E1ticos\r\n        if (this.getMass() === 0) return; // No afecta cuerpos sin masa\r\n    \r\n        const gravityEffect = Fisiks2DVector.ScalarMultiplication(time, gravity);\r\n        const newLinearVelocity = Fisiks2DVector.Add(this.getLinearVelocity(), gravityEffect);\r\n        this.setLinearVelocity(newLinearVelocity);\r\n    \r\n        const newPosition = Fisiks2DVector.Add(this.getPosition(), Fisiks2DVector.ScalarMultiplication(time, this.getLinearVelocity()));\r\n        this.setPosition(newPosition);\r\n    \r\n        const newCenter = Fisiks2DVector.Add(this.getCenter(), Fisiks2DVector.ScalarMultiplication(time, this.getLinearVelocity()));\r\n        this.setCenter(newCenter);\r\n    \r\n        const newAngle = this.getAngle() + this.getAngularVelocity() * time;\r\n        this.setAngle(newAngle);\r\n    \r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            this.vertices[i] = Fisiks2DVector.Add(this.vertices[i], Fisiks2DVector.ScalarMultiplication(time, this.getLinearVelocity()));\r\n        }\r\n    \r\n        this.setForce(Fisiks2DVector.Zero);\r\n    }\r\n    \r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksBody } from \"./FisiksBody\";\r\n\r\nconst keys: Record<string, boolean> = {\r\n    a: false,\r\n    s: false,\r\n    d: false,\r\n    w: false,\r\n};\r\n\r\ndocument.addEventListener('keydown', (event) => {\r\n    if (event.key in keys) {\r\n        keys[event.key] = true;\r\n    }\r\n});\r\n\r\ndocument.addEventListener('keyup', (event) => {\r\n    if (event.key in keys) {\r\n        keys[event.key] = false;\r\n    }\r\n});\r\n\r\nexport function FisiksBodyController(body: FisiksBody, secondsPassed: number, forceMagnitude: number = 400) {\r\n    let dx = 0;\r\n    let dy = 0;\r\n\r\n    if (keys.a) dx -= 1;\r\n    if (keys.d) dx += 1;\r\n    if (keys.w) dy -= 1;\r\n    if (keys.s) dy += 1;\r\n\r\n    if (dx !== 0 || dy !== 0) {\r\n        const forceDirection = Fisiks2DVector.Normalize(new Fisiks2DVector(dx, dy));\r\n        const force = Fisiks2DVector.ScalarMultiplication(forceMagnitude, forceDirection);\r\n\r\n        body.ApplyForce(force);\r\n    }\r\n}\r\n", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksAxisAlignedBoundingBox } from \"./FisiksAABB\";\r\nimport { FisiksBody, FisiksBodyBox, FisiksBodyCircle } from \"./FisiksBody\";\r\nimport { FisiksCollisionManifold } from \"./FisiksCollisionManifold\";\r\nimport { Segment } from \"./utils/utils\";\r\n\r\nexport interface CollisionDetails {\r\n    bodyA: FisiksBody, \r\n    bodyB: FisiksBody, \r\n    normal: Fisiks2DVector, \r\n    depth: number,\r\n    contactPoints: Fisiks2DVector[];\r\n}\r\n\r\ninterface DistanceContactPoint {\r\n    distanceSq: number;\r\n    contactPoint: Fisiks2DVector;\r\n}\r\n\r\nexport class FisiksCollisions {\r\n    static BroadPhase(A: FisiksAxisAlignedBoundingBox, B: FisiksAxisAlignedBoundingBox) : boolean {\r\n        if(A.max.x <= A.min.x || B.max.x <= A.min.x || A.max.y <= A.min.y || B.max.y <= A.min.y) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public static NarrowPashe(BodyA: FisiksBody, BodyB: FisiksBody): CollisionDetails | undefined {\r\n        if(BodyA instanceof FisiksBodyCircle && BodyB instanceof FisiksBodyCircle){\r\n            return this.IntersectCircles(BodyA, BodyB);\r\n        }\r\n\r\n        if(BodyA instanceof FisiksBodyBox && BodyB instanceof FisiksBodyBox){\r\n            return this.IntersectPolygons(BodyA, BodyB);\r\n        }\r\n\r\n        if(BodyA instanceof FisiksBodyCircle && BodyB instanceof FisiksBodyBox){\r\n            return this.IntersectCirclePolygon(BodyA, BodyB);\r\n        } \r\n\r\n        if(BodyA instanceof FisiksBodyBox && BodyB instanceof FisiksBodyCircle){\r\n            return this.IntersectCirclePolygon(BodyB, BodyA);\r\n        } \r\n    }\r\n\r\n    static SolveCollision(bodyA: FisiksBody, bodyB: FisiksBody, normal: Fisiks2DVector): void {\r\n        let inverseMassA = bodyA.getStatic() ? 0 : (1 / bodyA.getMass());\r\n        let inverseMassB = bodyB.getStatic() ? 0 : (1 / bodyB.getMass());\r\n    \r\n        let restitution = Math.min(bodyA.getRestitution(), bodyB.getRestitution());\r\n        let relativeVelocity = Fisiks2DVector.Difference(bodyB.getLinearVelocity(), bodyA.getLinearVelocity());\r\n    \r\n        if (Fisiks2DVector.DotProduct(relativeVelocity, normal) > 0) return; \r\n    \r\n        let impulseNumerator = -(1 + restitution) * Fisiks2DVector.DotProduct(relativeVelocity, normal);\r\n        let impulseDenominator = inverseMassA + inverseMassB;\r\n    \r\n        if (impulseDenominator === 0) return;\r\n    \r\n        let impulseMag = impulseNumerator / impulseDenominator;\r\n        let impulse = Fisiks2DVector.ScalarMultiplication(impulseMag, normal);\r\n\r\n        const newLinearVelocityA = Fisiks2DVector.Add(\r\n            bodyA.getLinearVelocity(),\r\n            Fisiks2DVector.ScalarMultiplication(-inverseMassA, impulse)\r\n        );\r\n\r\n        const newLinearVelocityB = Fisiks2DVector.Add(\r\n            bodyB.getLinearVelocity(),\r\n            Fisiks2DVector.ScalarMultiplication(inverseMassB, impulse)\r\n        );\r\n\r\n        bodyA.setLinearVelocity(newLinearVelocityA);\r\n        bodyB.setLinearVelocity(newLinearVelocityB);\r\n    }\r\n\r\n    static SolveCollisionWithRotation(contact: FisiksCollisionManifold): void {\r\n        const { bodyA, bodyB, normal } = contact;\r\n\r\n        const inverseMassA = bodyA.getStatic() ? 0 : (1 / bodyA.getMass());\r\n        const inverseMassB = bodyB.getStatic() ? 0 : (1 / bodyB.getMass());\r\n\r\n        const restitution = Math.min(bodyA.getRestitution(), bodyB.getRestitution());\r\n\r\n        const inverseInertiaA = (bodyA.getInertia() === 0) ? 0 : (1 / bodyA.getInertia());\r\n        const inverseInertiaB = (bodyB.getInertia() === 0) ? 0 : (1 / bodyB.getInertia()); \r\n\r\n        let contactList = contact.contactPoints;\r\n        let impulseList = [];\r\n        let raList = [];\r\n        let rbList = [];\r\n\r\n        for(let i = 0; i < contactList.length; i++){\r\n            impulseList[i] = Fisiks2DVector.Zero;\r\n            raList[i] = Fisiks2DVector.Zero;\r\n            rbList[i] = Fisiks2DVector.Zero;\r\n        }\r\n\r\n        for(let i = 0; i < contactList.length; i++){\r\n            const ra = Fisiks2DVector.Difference(contactList[i], bodyA.getCenter());\r\n            const rb = Fisiks2DVector.Difference(contactList[i], bodyB.getCenter());\r\n\r\n            raList[i] = ra;\r\n            rbList[i] = rb;\r\n\r\n            const raPerp = new Fisiks2DVector(-ra.y, ra.x);\r\n            const rbPerp = new Fisiks2DVector(-rb.y, rb.x);\r\n\r\n            const angularLinearVelocityA = Fisiks2DVector.ScalarMultiplication(bodyA.getAngularVelocity(), raPerp);\r\n            const angularLinearVelocityB = Fisiks2DVector.ScalarMultiplication(bodyB.getAngularVelocity(), rbPerp);\r\n\r\n            const relativeVelocity = Fisiks2DVector.Difference(\r\n                Fisiks2DVector.Add(bodyB.getLinearVelocity(), angularLinearVelocityB),\r\n                Fisiks2DVector.Add(bodyA.getLinearVelocity(), angularLinearVelocityA)\r\n            )\r\n\r\n            const contactVelocityMag = Fisiks2DVector.DotProduct(relativeVelocity, normal);\r\n\r\n            if (Math.abs(contactVelocityMag) < 0.0001) continue;\r\n\r\n            const raPerpDotN = Fisiks2DVector.DotProduct(raPerp, normal);\r\n            const rbPerpDotN = Fisiks2DVector.DotProduct(rbPerp, normal);\r\n\r\n            const impulseDenominator = inverseMassA + inverseMassB + \r\n                (raPerpDotN * raPerpDotN) * inverseInertiaA + \r\n                (rbPerpDotN * rbPerpDotN) * inverseInertiaB;\r\n\r\n            const impulseNumerator = -(1 + restitution) * contactVelocityMag;\r\n\r\n            const impulseMag = (impulseNumerator / impulseDenominator);\r\n            const impulse = Fisiks2DVector.ScalarMultiplication(impulseMag, normal);\r\n\r\n            impulseList[i] = impulse;\r\n        }\r\n\r\n        for(let i = 0; i < contactList.length; i++) {\r\n            const impulse = impulseList[i];\r\n            const ra = raList[i];\r\n            const rb = rbList[i];\r\n\r\n            const newlinearVelocityA = Fisiks2DVector.Add(\r\n                bodyA.getLinearVelocity(),\r\n                Fisiks2DVector.ScalarMultiplication(-inverseMassA, impulse)\r\n            );\r\n            bodyA.setLinearVelocity(newlinearVelocityA);\r\n\r\n            const newlinearVelocityB = Fisiks2DVector.Add(\r\n                bodyB.getLinearVelocity(),\r\n                Fisiks2DVector.ScalarMultiplication(inverseMassB, impulse)\r\n            );\r\n            bodyB.setLinearVelocity(newlinearVelocityB);\r\n\r\n            const newAngularVelocityA = bodyA.getAngularVelocity() - Fisiks2DVector.CrossProduct(ra, impulse) * inverseInertiaA;\r\n            bodyA.setAngularVelocity(newAngularVelocityA);\r\n\r\n            const newAngularVelocityB = bodyB.getAngularVelocity() + Fisiks2DVector.CrossProduct(rb, impulse) * inverseInertiaB;\r\n            bodyB.setAngularVelocity(newAngularVelocityB);\r\n        }\r\n    }\r\n\r\n    static SeparateBodies(bodyA: FisiksBody, bodyB:FisiksBody, normal: Fisiks2DVector, depth: number){\r\n        if (bodyA.getStatic() && bodyB.getStatic()) {\r\n            return\r\n        };\r\n    \r\n        if (bodyA.getStatic()) {\r\n            bodyB.Move(Fisiks2DVector.ScalarMultiplication(depth, normal));\r\n        } else if (bodyB.getStatic()) {\r\n            bodyA.Move(Fisiks2DVector.ScalarMultiplication(-depth, normal));\r\n        } else {\r\n            let halfDepth = depth / 2;\r\n            bodyA.Move(Fisiks2DVector.ScalarMultiplication(-halfDepth, normal));\r\n            bodyB.Move(Fisiks2DVector.ScalarMultiplication(halfDepth, normal));\r\n        }\r\n    }\r\n\r\n    static IntersectPolygons(PolygonA: FisiksBodyBox, PolygonB: FisiksBodyBox): CollisionDetails | undefined {\r\n        const verticesA: Fisiks2DVector[] = PolygonA.getVertices();\r\n        const verticesB: Fisiks2DVector[] = PolygonB.getVertices();\r\n\r\n        let normal: Fisiks2DVector = Fisiks2DVector.Zero;\r\n        let depth: number = Number.MAX_VALUE; \r\n\r\n        for (let i = 0; i < verticesA.length; i++) {\r\n            const VertexA: Fisiks2DVector = verticesA[i];\r\n            const VertexB: Fisiks2DVector = verticesA[(i + 1) % verticesA.length];\r\n            const edge: Fisiks2DVector = Fisiks2DVector.Difference(VertexB, VertexA);\r\n\r\n            let axis: Fisiks2DVector = new Fisiks2DVector(edge.y * -1, edge.x);\r\n            axis = Fisiks2DVector.Normalize(axis)\r\n\r\n            const projA = this.ProjectVertices(verticesA, axis);\r\n            const projB = this.ProjectVertices(verticesB, axis);\r\n\r\n            if(projA.min >= projB.max || projB.min >= projA.max)\r\n            {\r\n                return;\r\n            }\r\n\r\n            const axisDepth: number = Math.min(projB.max - projA.min, projA.max - projB.min); \r\n            \r\n            if(axisDepth < depth) {\r\n                depth = axisDepth;\r\n                normal = axis;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < verticesB.length; i++) {\r\n            const VertexA: Fisiks2DVector = verticesB[i];\r\n            const VertexB: Fisiks2DVector = verticesB[(i + 1) % verticesB.length];\r\n            const edge: Fisiks2DVector = Fisiks2DVector.Difference(VertexB, VertexA);\r\n            \r\n            let axis: Fisiks2DVector = new Fisiks2DVector(edge.y * -1, edge.x);\r\n            axis = Fisiks2DVector.Normalize(axis)\r\n\r\n            const projA = this.ProjectVertices(verticesA, axis);\r\n            const projB = this.ProjectVertices(verticesB, axis);\r\n\r\n            if (projA.min >= projB.max || projB.min >= projA.max){\r\n                return;\r\n            }\r\n\r\n            const axisDepth: number = Math.min(projB.max - projA.min, projA.max - projB.min); \r\n            \r\n            if(axisDepth < depth) {\r\n                depth = axisDepth;\r\n                normal = axis;\r\n            }\r\n        }\r\n\r\n        let direction: Fisiks2DVector = Fisiks2DVector.Difference(PolygonB.getCenter(), PolygonA.getCenter()); \r\n        \r\n        if(Fisiks2DVector.DotProduct(direction, normal) < 0){\r\n            normal = Fisiks2DVector.ScalarMultiplication(-1, normal);\r\n        }\r\n\r\n        const contactPoints = this.FindContactsPointsPolygons(PolygonA, PolygonB);\r\n\r\n        const Details: CollisionDetails = {\r\n            bodyA: PolygonA,\r\n            bodyB: PolygonB,\r\n            normal,\r\n            depth,\r\n            contactPoints\r\n        } \r\n\r\n        return Details;\r\n    }\r\n\r\n    static FindContactsPointsPolygons(PolygonA: FisiksBodyBox, PolygonB: FisiksBodyBox): Fisiks2DVector[] {\r\n        let minDistanceSq: number = Number.MAX_VALUE;\r\n        let contactPoints: Fisiks2DVector[] = [];\r\n        const epsilon = 1e-6;\r\n    \r\n        const findContacts = (sourcePolygon: FisiksBodyBox, targetPolygon: FisiksBodyBox) => {\r\n            for (let i = 0; i < sourcePolygon.getVertices().length; i++) {\r\n                const point = sourcePolygon.getVertices()[i];\r\n    \r\n                for (let j = 0; j < targetPolygon.getVertices().length; j++) {\r\n                    const currentVertex = targetPolygon.getVertices()[j];\r\n                    const nextVertex = targetPolygon.getVertices()[(j + 1) % targetPolygon.getVertices().length];\r\n                    const segment = new Segment(currentVertex, nextVertex);\r\n    \r\n                    const { contactPoint, distanceSq } = this.FindDistancePointSegment(point, segment);\r\n    \r\n                    if (distanceSq < minDistanceSq - epsilon) {\r\n                        minDistanceSq = distanceSq;\r\n                        contactPoints = [contactPoint];\r\n                    } else if (Math.abs(distanceSq - minDistanceSq) < epsilon) {\r\n                        contactPoints.push(contactPoint);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    \r\n        findContacts(PolygonA, PolygonB);\r\n        findContacts(PolygonB, PolygonA);\r\n    \r\n        return contactPoints;\r\n    }\r\n    \r\n    static IntersectCirclePolygon(Circle: FisiksBodyCircle, Polygon: FisiksBodyBox): CollisionDetails | undefined {\r\n\r\n        const vertices: Fisiks2DVector[] = Polygon.getVertices();\r\n\r\n        let normal: Fisiks2DVector = Fisiks2DVector.Zero;\r\n        let depth: number = Number.MAX_VALUE; \r\n\r\n        let axis: Fisiks2DVector = Fisiks2DVector.Zero;\r\n        const epsilon = 1e-6;\r\n\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const VertexA: Fisiks2DVector = vertices[i];\r\n            const VertexB: Fisiks2DVector = vertices[(i + 1) % vertices.length];\r\n            const edge: Fisiks2DVector = Fisiks2DVector.Difference(VertexB, VertexA);\r\n\r\n            if (edge.GetMagnitude() < epsilon) continue;\r\n\r\n            axis = Fisiks2DVector.Normalize(new Fisiks2DVector(edge.y * -1, edge.x));\r\n            \r\n            const { min: minA, max: maxA } = this.ProjectVertices(vertices, axis);\r\n            const { min: minB, max: maxB } = this.ProjectCircle(Circle, axis);\r\n\r\n            if (minA > maxB + epsilon || minB > maxA + epsilon) {\r\n                return;\r\n            }\r\n\r\n            const axisDepth: number = Math.min(maxB - minA, maxA - minB); \r\n            \r\n            if(axisDepth < depth){\r\n                depth = axisDepth;\r\n                normal = axis;\r\n            }\r\n        }\r\n\r\n        const closesPointIndex: number = this.FindClosesPointIndex(Circle, vertices);\r\n        if (closesPointIndex === -1) return;\r\n\r\n        const closesPoint: Fisiks2DVector = vertices[closesPointIndex];\r\n\r\n        axis = Fisiks2DVector.Normalize(Fisiks2DVector.Difference(closesPoint, Circle.getPosition()));\r\n\r\n        const { min: minA, max: maxA } = this.ProjectVertices(vertices, axis);\r\n        const { min: minB, max: maxB } = this.ProjectCircle(Circle, axis);\r\n\r\n        if (minA > maxB + epsilon || minB > maxA + epsilon) {\r\n            return;\r\n        }\r\n\r\n        const axisDepth: number = Math.min(maxB - minA, maxA - minB); \r\n        \r\n        if(axisDepth < depth){\r\n            depth = axisDepth;\r\n            normal = axis;\r\n        }\r\n\r\n        const magnitude = normal.GetMagnitude();\r\n\r\n        if (magnitude < epsilon) return;\r\n\r\n        depth = depth / magnitude;\r\n        normal = Fisiks2DVector.Normalize(normal);\r\n\r\n        if (!Polygon.getCenter() || !Circle.getPosition()) return;\r\n\r\n        let direction: Fisiks2DVector = Fisiks2DVector.Difference(Polygon.getCenter(), Circle.getPosition()); \r\n        \r\n        if (direction.GetMagnitude() < epsilon) return;\r\n\r\n        if(Fisiks2DVector.DotProduct(direction, normal) < 0){\r\n            normal = Fisiks2DVector.ScalarMultiplication(-1, normal);\r\n        }\r\n\r\n        let contact: Fisiks2DVector = Fisiks2DVector.Zero;\r\n        let minDistanceSq: number = Number.MAX_VALUE;\r\n\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const vertexA: Fisiks2DVector = vertices[i];\r\n            const vertexB: Fisiks2DVector = vertices[(i + 1) % vertices.length];\r\n            const segment: Segment = new Segment(vertexA, vertexB);\r\n\r\n            const { distanceSq, contactPoint } = this.FindDistancePointSegment(Circle.getPosition(), segment);\r\n\r\n            if (distanceSq < minDistanceSq) {\r\n                minDistanceSq = distanceSq;\r\n                contact = contactPoint;\r\n            }\r\n        }\r\n\r\n        const Details: CollisionDetails = {\r\n            bodyA: Circle,\r\n            bodyB: Polygon,\r\n            normal,\r\n            depth,\r\n            contactPoints: [contact]\r\n        } \r\n\r\n        return Details;\r\n    }\r\n\r\n    static IntersectCircles(CircleA: FisiksBodyCircle, CircleB: FisiksBodyCircle): CollisionDetails | undefined {\r\n        let normal: Fisiks2DVector = Fisiks2DVector.Zero;\r\n        let depth: number = 0;\r\n\r\n        let distance: number = Fisiks2DVector.Distance(CircleA.getPosition(), CircleB.getPosition());\r\n        let radii: number = CircleA.getRadius() + CircleB.getRadius();\r\n        \r\n        if(distance >= radii){\r\n            return;\r\n        }\r\n\r\n        let contactPoint: Fisiks2DVector = Fisiks2DVector.Add(\r\n            CircleA.getPosition(),\r\n            Fisiks2DVector.ScalarMultiplication(\r\n                CircleA.getRadius(),\r\n                Fisiks2DVector.Normalize(Fisiks2DVector.Difference(CircleB.getPosition(), CircleA.getPosition())))\r\n            ) \r\n\r\n\r\n        normal = Fisiks2DVector.Normalize(Fisiks2DVector.Difference(CircleB.getPosition(), CircleA.getPosition()));\r\n        depth = radii - distance;\r\n\r\n        const Details: CollisionDetails = {\r\n            bodyA: CircleA,\r\n            bodyB: CircleB,\r\n            normal,\r\n            depth,\r\n            contactPoints: [contactPoint]\r\n        } \r\n\r\n        return Details;\r\n    }\r\n\r\n    static FindDistancePointSegment(point: Fisiks2DVector, segment: Segment): DistanceContactPoint {\r\n        let contactPoint: Fisiks2DVector;\r\n    \r\n        const AB: Fisiks2DVector = Fisiks2DVector.Difference(segment.pointB, segment.pointA);\r\n        const AP: Fisiks2DVector = Fisiks2DVector.Difference(point, segment.pointA);\r\n    \r\n        const ABMagnitudeSquared: number = AB.GetSquaredMagnitude();\r\n    \r\n        if (ABMagnitudeSquared === 0) {\r\n            contactPoint = segment.pointA;\r\n        } else {\r\n            const projection: number = Fisiks2DVector.DotProduct(AP, AB);\r\n            const t: number = projection / ABMagnitudeSquared;\r\n    \r\n            if (t <= 0) {\r\n                contactPoint = segment.pointA;\r\n            } else if (t >= 1) {\r\n                contactPoint = segment.pointB;\r\n            } else {\r\n                contactPoint = Fisiks2DVector.Add(\r\n                    segment.pointA,\r\n                    Fisiks2DVector.ScalarMultiplication(t, AB)\r\n                );\r\n            }\r\n        }\r\n    \r\n        const distanceSquared = Fisiks2DVector.SquaredDistance(point, contactPoint);\r\n    \r\n        return {\r\n            distanceSq: distanceSquared,\r\n            contactPoint\r\n        };\r\n    }\r\n\r\n    static ProjectVertices(vertices: Fisiks2DVector[], axis: Fisiks2DVector): { min: number, max: number } {\r\n        let min = Number.MAX_VALUE;\r\n        let max = Number.MIN_VALUE;\r\n    \r\n        for(let i = 0; i < vertices.length; i++){\r\n            const vertex: Fisiks2DVector = vertices[i];\r\n            const projection: number = Fisiks2DVector.DotProduct(vertex, axis);\r\n            \r\n            if(projection < min) { min = projection;}\r\n            if(projection > max) { max = projection;}\r\n        }\r\n    \r\n        return { min, max };\r\n    }\r\n\r\n    static ProjectCircle(circle: FisiksBodyCircle, axis: Fisiks2DVector): { min: number, max: number } {\r\n        let direction: Fisiks2DVector = Fisiks2DVector.Normalize(axis);\r\n        let directionRadius: Fisiks2DVector = Fisiks2DVector.ScalarMultiplication(circle.getRadius(), direction);\r\n\r\n        let point1: Fisiks2DVector = Fisiks2DVector.Add(circle.getPosition(), directionRadius);\r\n        let point2: Fisiks2DVector = Fisiks2DVector.Difference(circle.getPosition(), directionRadius);\r\n\r\n        const min: number = Math.min(Fisiks2DVector.DotProduct(point1, axis), Fisiks2DVector.DotProduct(point2, axis));\r\n        const max: number = Math.max(Fisiks2DVector.DotProduct(point1, axis), Fisiks2DVector.DotProduct(point2, axis));\r\n\r\n        return { min, max };\r\n    }\r\n\r\n    static FindClosesPointIndex(Circle: FisiksBodyCircle, vertices: Fisiks2DVector[]): number {\r\n        let result: number = -1; \r\n        let minDistance: number = Number.MAX_VALUE;\r\n    \r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const vertex: Fisiks2DVector = vertices[i];\r\n            const distance: number = Fisiks2DVector.Distance(vertex, Circle.getPosition());\r\n\r\n            if(distance < minDistance){\r\n                minDistance = distance;\r\n                result = i;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksBody } from \"./FisiksBody\";\r\n\r\nexport class FisiksCollisionManifold {\r\n    readonly bodyA: FisiksBody; \r\n    readonly bodyB: FisiksBody;\r\n    readonly normal: Fisiks2DVector;\r\n    readonly depth: number;\r\n    readonly contactPoints: Fisiks2DVector[];\r\n\r\n    constructor(bodyA: FisiksBody, bodyB: FisiksBody, normal: Fisiks2DVector, depth: number, contactPoints: Fisiks2DVector[]){\r\n        this.bodyA = bodyA;\r\n        this.bodyB = bodyB;\r\n        this.normal = normal;\r\n        this.depth = depth;\r\n        this.contactPoints = contactPoints;\r\n    }\r\n}", "import { Fisiks2DVector } from \"./Fisiks2DVector\";\r\nimport { FisiksAxisAlignedBoundingBox } from \"./FisiksAABB\";\r\nimport { FisiksBody, FisiksBodyBox, FisiksBodyCircle } from \"./FisiksBody\";\r\nimport { FisiksCollisionManifold } from \"./FisiksCollisionManifold\";\r\nimport { CollisionDetails, FisiksCollisions } from \"./FisiksCollisions\";\r\nimport { FisiksObserver } from \"./FisiksObservers\";\r\nimport { FisiksShape } from \"./FisiksShape\";\r\nimport { id } from \"./utils/utils\";\r\n\r\nexport class FisiksDisplay {\r\n    width: number;\r\n    height: number;\r\n    canvas: HTMLCanvasElement;\r\n    context: CanvasRenderingContext2D;\r\n    oldTimeStamp: number = 0;\r\n\r\n    bodyList: FisiksBody[] = [];\r\n    bodyMap: Map<id, FisiksBody> = new Map();\r\n    gravity: Fisiks2DVector = Fisiks2DVector.Zero; \r\n\r\n    contactList: Set<FisiksCollisionManifold> = new Set(); \r\n\r\n    private showVertices: boolean = false;\r\n    private showAABB: boolean = false;\r\n    private showContactPoints: boolean = false;\r\n\r\n    private externalBehaviors: ((body: FisiksBody) => void)[] = [];\r\n    private observers: FisiksObserver[] = [];\r\n\r\n    setShowVertices(value: boolean){\r\n        this.showVertices = value;\r\n    }\r\n\r\n    getShowVertices(){\r\n        return this.showVertices;\r\n    }\r\n\r\n    setShowAABB(value: boolean){\r\n        this.showAABB = value;\r\n    }\r\n\r\n    getShowAABB(){\r\n        return this.showAABB;\r\n    }\r\n\r\n    addObserver(observer: FisiksObserver): void {\r\n        this.observers.push(observer);\r\n    }\r\n\r\n    removeObserver(observer: FisiksObserver): void {\r\n        const index = this.observers.indexOf(observer);\r\n        if (index >= 0) {\r\n            this.observers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    notifyObservers(body: FisiksBody): void {\r\n        for (let observer of this.observers) {\r\n            observer.update(body);\r\n        }\r\n    }\r\n\r\n    RegisterBehavior(behavior: (body: FisiksBody) => void): void {\r\n        this.externalBehaviors.push(behavior);\r\n    }\r\n\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.canvas = document.createElement(\"canvas\");\r\n        this.canvas.width = this.width;\r\n        this.canvas.height = this.height;\r\n\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n\r\n        if (!ctx) {\r\n            throw new Error(\"Could not get the 2D context of the canvas.\");\r\n        }\r\n\r\n        this.context = ctx;\r\n        this.bodyList = [];\r\n        this.bodyMap.clear();\r\n    }\r\n\r\n    GetCanvas(): HTMLCanvasElement {\r\n        return this.canvas;\r\n    }\r\n\r\n    GetContext(): CanvasRenderingContext2D {\r\n        return this.context;\r\n    }\r\n\r\n    AddBody(body: FisiksBody): void {\r\n        this.bodyList.push(body);\r\n        this.bodyMap.set(body.getId(), body); \r\n    }\r\n    \r\n    RemoveBody(id: id): void {\r\n        this.bodyList = this.bodyList.filter(body => body.getId() !== id);\r\n        this.bodyMap.delete(id); \r\n    }\r\n    \r\n    GetBody(id: id): FisiksBody | undefined {\r\n        return this.bodyMap.get(id);\r\n    }\r\n\r\n    SetGravity(amount: Fisiks2DVector){\r\n        this.gravity = amount;\r\n    }\r\n\r\n    StartGameLoop(): void {\r\n        requestAnimationFrame(this.GameLoop.bind(this));\r\n    }\r\n\r\n    private clearContext() {\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    } \r\n\r\n    private GameLoop(timeStamp: number): void {\r\n        const secondsPassed = (timeStamp - this.oldTimeStamp) / 1000;\r\n        this.oldTimeStamp = timeStamp;\r\n\r\n        this.clearContext()\r\n\r\n        const iterations = 30; \r\n        const subStepTime = secondsPassed / iterations;\r\n        \r\n\r\n        for (let step = 0; step < iterations; step++) {\r\n            this.UpdateBodies(subStepTime);\r\n            this.RenderBodies();\r\n            this.HandleCollisions();\r\n        }\r\n\r\n        requestAnimationFrame(this.GameLoop.bind(this));\r\n    }\r\n\r\n    private UpdateBodies(subStepTime: number): void {\r\n        for (let body of this.bodyList) {\r\n            for (const behavior of this.externalBehaviors) {\r\n                behavior(body);\r\n            }\r\n\r\n            body.Step(subStepTime, this.gravity);\r\n        }\r\n    }\r\n\r\n    private RenderBodies(){\r\n        for (let body of this.bodyList) {\r\n            body.Draw();\r\n        \r\n            if(this.getShowVertices() || this.getShowAABB()){\r\n                const context = body.getContext()\r\n\r\n                if(context instanceof CanvasRenderingContext2D){\r\n                    let points = [body.getCenter()]\r\n                    const AABB = body.getAABB();\r\n\r\n                    if(this.getShowAABB() && AABB instanceof FisiksAxisAlignedBoundingBox){\r\n                        points.push(AABB.min);\r\n                        points.push(AABB.max);\r\n                    }\r\n\r\n                    FisiksShape.DrawPoints(context, points)\r\n\r\n                    if(body instanceof FisiksBodyBox){\r\n                        FisiksShape.DrawPoints(context, body.getVertices())\r\n                    }\r\n                }\r\n            } \r\n\r\n            this.notifyObservers(body);\r\n        }\r\n    }\r\n\r\n\r\n    private HandleCollisions(): void {\r\n        this.contactList.clear();\r\n\r\n        for (let i = 0; i < this.bodyList.length - 1; i++) {\r\n            const bodyA = this.bodyList[i];\r\n            const bodyAAABB = bodyA.getAABB();\r\n\r\n            for (let j = i + 1; j < this.bodyList.length; j++) {\r\n                const bodyB = this.bodyList[j];\r\n                const bodyBAABB = bodyB.getAABB(); \r\n\r\n                if (bodyAAABB instanceof Error || bodyBAABB instanceof Error) continue;\r\n                if (!FisiksCollisions.BroadPhase(bodyAAABB, bodyBAABB)) continue;\r\n\r\n                const Details: CollisionDetails | undefined = FisiksCollisions.NarrowPashe(bodyA, bodyB);\r\n\r\n                if (Details) {\r\n                    const { bodyA, bodyB, normal, depth, contactPoints } = Details;\r\n\r\n                    const contact: FisiksCollisionManifold = new FisiksCollisionManifold(\r\n                        bodyA, bodyB, normal, depth, contactPoints\r\n                    );\r\n\r\n                    this.contactList.add(contact);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const contact of this.contactList) {\r\n            const { bodyA, bodyB, normal, depth, contactPoints } = contact;\r\n\r\n            if(this.showContactPoints){\r\n                FisiksShape.DrawPoints(this.GetContext(), contactPoints);\r\n            }\r\n\r\n            FisiksCollisions.SeparateBodies(bodyA, bodyB, normal, depth);\r\n            FisiksCollisions.SolveCollision(bodyA, bodyB, normal);\r\n            //FisiksCollisions.SolveCollisionWithRotation(contact)\r\n        }\r\n    }\r\n}\r\n", "import { FisiksBody } from \"./FisiksBody\";\r\n\r\nexport interface FisiksObserver {\r\n    update(body: FisiksBody): void;\r\n}\r\n\r\nexport class FisiksBodyObserver implements FisiksObserver {\r\n    update(body: FisiksBody): void {\r\n        /*\r\n        if (body.isColliding) {\r\n            console.log(`Body ${body.id} is colliding`);\r\n        }\r\n        */\r\n    }\r\n}\r\n"],
  "mappings": ";AAEO,IAAM,kBAAN,MAAM,gBAAe;AAAA,EAMxB,YAAY,GAAW,GAAW;AAC9B,SAAK,IAAI;AACT,SAAK,IAAI;AAAA,EACb;AAAA,EAEA,OAAc,IAAI,QAAwB,aAA6C;AACnF,WAAO,IAAI,gBAAe,OAAO,IAAI,YAAY,GAAG,OAAO,IAAI,YAAY,CAAC;AAAA,EAChF;AAAA,EAEA,OAAc,WAAW,SAAyB,YAA4C;AAC1F,WAAO,IAAI,gBAAe,QAAQ,IAAI,WAAW,GAAG,QAAQ,IAAI,WAAW,CAAC;AAAA,EAChF;AAAA,EAEA,OAAc,qBAAqB,QAAgB,QAAwB;AACvE,WAAO,IAAI,gBAAe,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC;AAAA,EAClE;AAAA,EAEA,OAAc,UAAU,QAAwC;AAC5D,UAAM,YAAoB,OAAO,aAAa;AAC9C,WAAO,IAAI,gBAAe,OAAO,IAAI,WAAW,OAAO,IAAI,SAAS;AAAA,EACxE;AAAA,EAEA,OAAc,SAAS,QAAwB,aAAqC;AAChF,UAAM,KAAa,YAAY,IAAI,OAAO;AAC1C,UAAM,KAAa,YAAY,IAAI,OAAO;AAE1C,WAAO,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAAA,EACtC;AAAA,EAEA,OAAc,gBAAgB,QAAwB,aAAqC;AACvF,UAAM,KAAa,YAAY,IAAI,OAAO;AAC1C,UAAM,KAAa,YAAY,IAAI,OAAO;AAE1C,WAAO,KAAK,KAAK,KAAK;AAAA,EAC1B;AAAA,EAEA,OAAc,UAAU,QAAwB,WAA4C;AACxF,UAAM,iBAAiB,IAAI;AAAA,MACvB,OAAO,IAAI,UAAU;AAAA,MACrB,OAAO,IAAI,UAAU;AAAA,IACzB;AAEA,UAAM,iBAAiB,IAAI;AAAA,MACvB,UAAU,MAAM,eAAe,IAAI,UAAU,MAAM,eAAe;AAAA,MAClE,UAAU,MAAM,eAAe,IAAI,UAAU,MAAM,eAAe;AAAA,IACtE;AAEA,WAAO,IAAI,gBAAe,eAAe,IAAI,UAAU,WAAW,eAAe,IAAI,UAAU,SAAS;AAAA,EAC5G;AAAA,EAEA,OAAc,WAAW,QAAwB,aAAqC;AAClF,WAAO,OAAO,IAAI,YAAY,IAAI,OAAO,IAAI,YAAY;AAAA,EAC7D;AAAA,EAEA,OAAc,aAAa,QAAwB,aAAqC;AACpF,WAAO,OAAO,IAAI,YAAY,IAAI,OAAO,IAAI,YAAY;AAAA,EAC7D;AAAA,EAEO,eAAuB;AAC1B,WAAO,KAAK,KAAM,KAAK,IAAI,KAAK,IAAM,KAAK,IAAI,KAAK,CAAE;AAAA,EAC1D;AAAA,EAEO,sBAA8B;AACjC,WAAQ,KAAK,IAAI,KAAK,IAAM,KAAK,IAAI,KAAK;AAAA,EAC9C;AAAA,EAEO,UAAU,aAAsC;AACnD,WAAQ,KAAK,MAAM,YAAY,KAAO,KAAK,MAAM,YAAY;AAAA,EACjE;AACJ;AA3Ea,gBAIc,OAAuB,IAAI,gBAAe,GAAG,CAAC;AAJlE,IAAM,iBAAN;;;ACAA,IAAM,+BAAN,MAAmC;AAAA,EAItC,YAAY,KAAqB,KAAoB;AACjD,SAAK,MAAM;AACX,SAAK,MAAM;AAAA,EACf;AACJ;;;ACPO,IAAK,YAAL,kBAAKA,eAAL;AAAiB,EAAAA,sBAAA;AAAK,EAAAA,sBAAA;AAAjB,SAAAA;AAAA,GAAA;AAEL,IAAM,cAAN,MAAkB;AAAA,EACrB,OAAc,WAAW,SAAmC,UAA0B,OAAe,QAAqB;AACtH,YAAQ,UAAU;AAClB,YAAQ,IAAI,SAAS,GAAG,SAAS,GAAG,QAAQ,GAAG,IAAI,KAAK,EAAE;AAC1D,YAAQ,YAAY;AACpB,YAAQ,KAAK;AAAA,EACjB;AAAA,EAEA,OAAc,QAAQ,SAAmC,UAA0B,OAAe,OAAe,QAAqB;AAClI,YAAQ,UAAU;AAClB,YAAQ,KAAK,SAAS,GAAG,SAAS,GAAG,OAAO,MAAM;AAClD,YAAQ,YAAY;AACpB,YAAQ,KAAK;AAAA,EACjB;AAAA,EAEA,OAAc,aAAa,SAAmC,UAA4B,OAAe,MAAmC;AACxI,eAAW,UAAU,UAAU;AAC3B,cAAQ,UAAU;AAClB,cAAQ,IAAI,OAAO,GAAG,OAAO,GAAG,GAAG,GAAG,IAAI,KAAK,EAAE;AACjD,cAAQ,YAAY;AACpB,cAAQ,KAAK;AAAA,IACjB;AAEA,QAAI,eAAiC,CAAC,KAAK,KAAK,KAAK,GAAG;AAExD,eAAW,UAAU,cAAc;AAC/B,cAAQ,UAAU;AAClB,cAAQ,IAAI,OAAO,GAAG,OAAO,GAAG,GAAG,GAAG,IAAI,KAAK,EAAE;AACjD,cAAQ,YAAY;AACpB,cAAQ,KAAK;AAAA,IACjB;AAAA,EACJ;AAAA,EAEA,OAAc,WAAW,SAAmC,QAAyB;AACjF,eAAW,SAAS,QAAQ;AACxB,cAAQ,UAAU;AAClB,cAAQ,IAAI,MAAM,GAAG,MAAM,GAAG,GAAG,GAAG,IAAI,KAAK,EAAE;AAC/C,cAAQ,YAAY;AACpB,cAAQ,KAAK;AAAA,IACjB;AAAA,EACJ;AAAA,EAEA,OAAc,SAAS,SAAmC,MAAsB,UAAgC;AAC5G,YAAQ,UAAU;AAClB,YAAQ,OAAO,SAAS,GAAG,SAAS,CAAC;AACrC,YAAQ,OAAO,SAAS,IAAI,KAAK,IAAI,IAAI,SAAS,IAAI,KAAK,IAAI,EAAE;AACjE,YAAQ,cAAc;AACtB,YAAQ,YAAY;AACpB,YAAQ,OAAO;AAAA,EACnB;AAAA,EAEA,OAAc,YAAY,SAAmC,UAA4B,OAAsB;AAE3G,QAAI,SAAS,SAAS,GAAG;AACrB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC9D;AAEA,YAAQ,UAAU;AAClB,YAAQ,OAAO,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC;AAE3C,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,cAAQ,OAAO,SAAS,CAAC,EAAE,GAAG,SAAS,CAAC,EAAE,CAAC;AAAA,IAC/C;AAEA,YAAQ,UAAU;AAClB,YAAQ,YAAY;AACpB,YAAQ,KAAK;AAAA,EACjB;AACJ;;;ACvEO,IAAM,mBAAN,MAAM,iBAAgB;AAAA,EAMzB,YAAY,UAA0B,OAAc;AAChD,SAAK,YAAY,SAAS;AAC1B,SAAK,YAAY,SAAS;AAC1B,SAAK,MAAM,KAAK,IAAI,KAAK;AACzB,SAAK,MAAM,KAAK,IAAI,KAAK;AAAA,EAC7B;AAGJ;AAda,iBAac,OAAwB,IAAI,iBAAgB,eAAe,MAAM,CAAC;AAbtF,IAAM,kBAAN;;;ACEA,SAAS,aAAiB;AAC7B,QAAM,UAAU,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,CAAC;AAC/D,SAAO,GAAG,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC;AAC9D;AAEO,IAAM,UAAN,MAAc;AAAA,EAIjB,YAAY,QAAwB,QAAuB;AACvD,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,cAA8B;AAC1B,UAAM,WAA2B,eAAe,WAAW,KAAK,QAAQ,KAAK,MAAM;AACnF,WAAO;AAAA,EACX;AACJ;;;AChBO,IAAM,aAAN,MAAiB;AAAA,EA8BpB,YAAY,SAA0C,UAAyB;AA7B/E,SAAiB,KAAS,WAAW;AAGrC,SAAQ,mBAAmC,eAAe;AAG1D,SAAQ,SAAyB,eAAe;AAChD,SAAQ,QAAgB;AAExB,SAAQ,iBAAiC,eAAe;AACxD,SAAQ,mBAAmC,eAAe;AAE1D,SAAQ,mBAA2B;AACnC,SAAQ,qBAAqC,eAAe;AAE5D,SAAQ,QAAgB;AACxB,SAAQ,kBAA0B;AAElC,SAAQ,UAAkB;AAC1B,SAAQ,QAAwB,eAAe;AAC/C,SAAQ,cAAuB;AAE/B,SAAQ,OAAe;AACvB,SAAQ,UAAkB;AAC1B,SAAQ,OAAe;AACvB,SAAQ,cAAsB;AAE9B,SAAQ,WAAoB;AAGxB,SAAK,UAAU;AACf,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,oBAAoB,UAAyB;AACzC,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEA,sBAAqB;AACjB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,oBAAoB,UAAyB;AACzC,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEA,sBAAqB;AACjB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,oBAAoB,QAAe;AAC/B,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEA,sBAAqB;AACjB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,QAAO;AACH,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,aAAY;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,YAAY,UAAyB;AACjC,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,cAAa;AACT,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,UAAU,QAAuB;AAC7B,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,YAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,SAAS,OAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,WAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,QAAQ,MAAa;AACjB,SAAK,OAAO;AAAA,EAChB;AAAA,EAEA,QAAQ,MAAa;AACjB,SAAK,OAAO;AAAA,EAChB;AAAA,EAEA,UAAS;AACL,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAW,SAAgB;AACvB,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,eAAe,aAAoB;AAC/B,SAAK,cAAc;AAAA,EACvB;AAAA,EAEA,iBAAgB;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,UAAU,WAAmB;AACzB,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,YAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAW,SAAgB;AACvB,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,aAAY;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,kBAAkB,gBAA+B;AAC7C,SAAK,iBAAiB;AAAA,EAC1B;AAAA,EAEA,oBAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,sBAAsB,oBAA2B;AAC7C,SAAK,qBAAqB,KAAK;AAAA,EACnC;AAAA,EAEA,wBAAuB;AACnB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,mBAAmB,iBAAwB;AACvC,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,qBAAoB;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,SAAS,OAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,WAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,SAAS,QAAuB;AAC5B,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,WAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,OAAO,QAAe;AAAA,EAAC;AAAA,EACvB,OAAM;AAAA,EAAC;AAAA,EACP,KAAK,MAAc,SAAwB;AAAA,EAAC;AAAA,EAC5C,KAAK,QAAuB;AAAA,EAAC;AAAA,EAC7B,OAAO,UAAyB;AAAA,EAAC;AAAA,EACjC,eAAc;AAAA,EAAC;AAAA,EACf,WAAU;AAAA,EAAC;AAAA,EAEX,UAAgD;AAC5C,WAAO,IAAI,MAAM,WAAW;AAAA,EAChC;AAAA,EAEA,WAAW,QAA6B;AACpC,SAAK,QAAQ;AAAA,EACjB;AAEJ;AAEO,IAAM,mBAAN,cAA+B,WAAW;AAAA,EAG7C,YAAY,SAA0C,UAA0B,QAAe;AAC3F,UAAM,SAAS,QAAQ;AACvB,SAAK,SAAS;AAEd,UAAM,oBAA4B,KAAK,KAAK,KAAK,IAAI,QAAQ,CAAC;AAC9D,UAAM,UAAU,MAAM,oBAAoB,KAAK,IAAI,KAAK,QAAQ,CAAC;AAEjE,SAAK,UAAU,QAAQ;AACvB,SAAK,QAAQ,iBAAiB;AAC9B,SAAK,WAAW,iBAAiB;AACjC,SAAK,QAAQ,iBAAiB;AAC9B,SAAK,WAAW,OAAO;AAAA,EAC3B;AAAA,EAES,YAAY,UAAyB;AAC1C,UAAM,YAAY,QAAQ;AAC1B,SAAK,UAAU,QAAQ;AAAA,EAC3B;AAAA,EAEA,YAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAES,OAAM;AACX,UAAM,UAAU,KAAK,WAAW;AAEhC,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,WAAW,SAAS,KAAK,YAAY,GAAG,KAAK,SAAS,GAAG,KAAK,MAAM;AAAA,IACpF,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAES,eAAc;AACnB,UAAM,UAAU,MAAM,WAAW;AAEjC,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,WAAW,SAAS,CAAC,KAAK,YAAY,CAAC,CAAC;AAAA,IACxD,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAES,WAAU;AACf,UAAM,UAAU,KAAK,WAAW;AAChC,UAAM,OAAO,KAAK,QAAQ;AAE1B,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,WAAW,SAAS,CAAC,KAAK,KAAK,KAAK,GAAG,CAAC;AAAA,IACxD,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAEA,UAAS;AACL,QAAI,MAAsB,IAAI,eAAe,OAAO,WAAW,OAAO,SAAS;AAC/E,QAAI,MAAsB,IAAI,eAAe,OAAO,WAAW,OAAO,SAAS;AAE/E,UAAM,IAAI;AAAA,MACN,KAAK,UAAU,EAAE,IAAI,KAAK;AAAA,MAC1B,KAAK,UAAU,EAAE,IAAI,KAAK;AAAA,IAC9B;AAEA,UAAM,IAAI;AAAA,MACN,KAAK,UAAU,EAAE,IAAI,KAAK;AAAA,MAC1B,KAAK,UAAU,EAAE,IAAI,KAAK;AAAA,IAC9B;AAEA,WAAO,IAAI,6BAA6B,KAAK,GAAG;AAAA,EACpD;AAAA,EAES,OAAO,UAAyB;AACrC,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AAAA,EAC3B;AAAA,EAES,KAAK,QAA8B;AACxC,UAAM,cAAc,eAAe,IAAI,KAAK,YAAY,GAAG,MAAM;AACjE,SAAK,YAAY,WAAW;AAE5B,UAAM,YAAY,eAAe,IAAI,KAAK,UAAU,GAAG,MAAM;AAC7D,SAAK,UAAU,SAAS;AAAA,EAC5B;AAAA,EAES,KAAK,MAAc,SAA+B;AACvD,QAAI,KAAK,UAAU,EAAG;AACtB,QAAI,KAAK,QAAQ,MAAM,EAAG;AAE1B,UAAM,gBAAgB,eAAe,qBAAqB,MAAM,OAAO;AACvE,UAAM,oBAAoB,eAAe,IAAI,KAAK,kBAAkB,GAAG,aAAa;AACpF,SAAK,kBAAkB,iBAAiB;AAExC,UAAM,cAAc,eAAe,IAAI,KAAK,YAAY,GAAG,eAAe,qBAAqB,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAC9H,SAAK,YAAY,WAAW;AAE5B,UAAM,YAAY,eAAe,IAAI,KAAK,UAAU,GAAG,eAAe,qBAAqB,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAC1H,SAAK,UAAU,SAAS;AAExB,UAAM,WAAW,KAAK,SAAS,IAAI,KAAK,mBAAmB,IAAI;AAC/D,SAAK,SAAS,QAAQ;AAEtB,SAAK,SAAS,eAAe,IAAI;AAAA,EACrC;AACJ;AAEO,IAAM,gBAAN,cAA4B,WAAW;AAAA,EAM1C,YAAY,SAA0C,UAA0B,OAAe,QAAe;AAC1G,UAAM,SAAS,QAAQ;AAN3B,SAAQ,QAAgB;AACxB,SAAQ,SAAiB;AACzB,SAAQ,WAA6B,CAAC;AACtC,SAAQ,sBAAwC,CAAC;AAI7C,SAAK,QAAQ;AACb,SAAK,SAAS;AAEd,UAAM,SAAS,IAAI,eAAe,SAAS,IAAI,QAAM,GAAG,SAAS,IAAI,SAAO,CAAC;AAC7E,UAAM,oBAA4B,QAAQ;AAE1C,SAAK,UAAU,MAAM;AACrB,SAAK,QAAQ,iBAAiB;AAC9B,SAAK,QAAQ,iBAAiB;AAC9B,SAAK,WAAW,iBAAiB;AAEjC,UAAM,UAAW,IAAI,KAAM,KAAK,QAAQ,KAAK,KAAK,IAAI,KAAK,QAAQ,CAAC,IAAI,KAAK,IAAI,KAAK,OAAO,CAAC;AAE9F,SAAK,WAAW,OAAO;AAEvB,QAAG,KAAK,oBAAoB,WAAW,GAAE;AACrC,WAAK,WAAW,KAAK,kBAAkB,OAAO,MAAM;AAAA,IACxD,OAAO;AACH,WAAK,WAAW,KAAK;AAAA,IACzB;AAAA,EACJ;AAAA,EAEA,YAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,cAAa;AACT,WAAO,KAAK;AAAA,EAChB;AAAA,EAES,YAAY,UAAyB;AAC1C,UAAM,YAAY,QAAQ;AAE1B,UAAM,YAAY,IAAI,eAAe,SAAS,IAAI,KAAK,QAAM,GAAG,SAAS,IAAI,KAAK,SAAO,CAAC;AAC1F,SAAK,UAAU,SAAS;AAExB,UAAM,cAAc,KAAK,kBAAkB,KAAK,OAAO,KAAK,MAAM;AAClE,SAAK,WAAW;AAAA,EACpB;AAAA,EAES,OAAM;AACX,UAAM,UAAU,KAAK,WAAW;AAEhC,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,YAAY,SAAS,KAAK,UAAU,KAAK,SAAS,CAAC;AAAA,IACnE,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAEA,eAAc;AACV,UAAM,UAAU,KAAK,WAAW;AAEhC,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,WAAW,SAAS,KAAK,SAAS,OAAO,CAAC,KAAK,UAAU,CAAC,CAAC,CAAC;AAAA,IAC5E,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAES,WAAU;AACf,UAAM,UAAU,KAAK,WAAW;AAChC,UAAM,OAAO,KAAK,QAAQ;AAE1B,QAAI,mBAAmB,0BAA0B;AAC7C,kBAAY,WAAW,SAAS,CAAC,KAAK,KAAK,KAAK,GAAG,CAAC;AAAA,IACxD,OAAO;AACH,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EACJ;AAAA,EAEA,UAAwC;AACpC,QAAI,MAAsB,IAAI,eAAe,OAAO,WAAW,OAAO,SAAS;AAC/E,QAAI,MAAsB,IAAI,eAAe,OAAO,WAAW,OAAO,SAAS;AAE3E,SAAK,SAAS,QAAQ,YAAU;AAC5B,UAAG,OAAO,IAAI,IAAI,GAAE;AAChB,cAAM,IAAI;AAAA,UACN,OAAO;AAAA,UACP,IAAI;AAAA,QACR;AAAA,MACJ;AACA,UAAG,OAAO,IAAI,IAAI,GAAE;AAChB,cAAM,IAAI;AAAA,UACN,IAAI;AAAA,UACJ,OAAO;AAAA,QACX;AAAA,MACJ;AAEA,UAAG,OAAO,IAAI,IAAI,GAAE;AAChB,cAAM,IAAI;AAAA,UACN,OAAO;AAAA,UACP,IAAI;AAAA,QACR;AAAA,MACJ;AAEA,UAAG,OAAO,IAAI,IAAI,GAAE;AAChB,cAAM,IAAI;AAAA,UACN,IAAI;AAAA,UACJ,OAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,WAAO,IAAI,6BAA6B,KAAK,GAAG;AAAA,EACxD;AAAA,EAEA,kBAAkB,OAAe,QAAiC;AAC9D,QAAI,WAA6B,CAAC;AAElC,QAAI,OAAe,KAAK,YAAY,EAAE;AACtC,QAAI,QAAgB,KAAK,YAAY,EAAE,IAAI;AAC3C,QAAI,SAAiB,KAAK,YAAY,EAAE,IAAI;AAC5C,QAAI,MAAc,KAAK,YAAY,EAAE;AAErC,aAAS,CAAC,IAAI,IAAI,eAAe,MAAM,GAAG;AAC1C,aAAS,CAAC,IAAI,IAAI,eAAe,OAAO,GAAG;AAC3C,aAAS,CAAC,IAAI,IAAI,eAAe,OAAO,MAAM;AAC9C,aAAS,CAAC,IAAI,IAAI,eAAe,MAAM,MAAM;AAE7C,WAAO;AAAA,EACX;AAAA,EAEA,wBAA0C;AACtC,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC3C,YAAM,SAAyB,KAAK,SAAS,CAAC;AAC9C,YAAM,YAA6B,IAAI,gBAAgB,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC;AACxF,YAAM,gBAAgB,eAAe,UAAU,QAAQ,SAAS;AAEhE,WAAK,oBAAoB,CAAC,IAAI;AAAA,IAClC;AAEA,WAAO,KAAK;AAAA,EAChB;AAAA,EAES,OAAO,UAAyB;AACrC,SAAK,YAAY,QAAQ;AAEzB,UAAM,YAAY,IAAI,eAAe,SAAS,IAAI,KAAK,QAAM,GAAG,SAAS,IAAI,KAAK,SAAO,CAAC;AAC1F,SAAK,UAAU,SAAS;AAExB,SAAK,WAAW,KAAK,kBAAkB,KAAK,OAAO,KAAK,MAAM;AAAA,EAClE;AAAA,EAES,KAAK,QAAwB;AAClC,UAAM,cAAc,eAAe,IAAI,KAAK,YAAY,GAAG,MAAM;AACjE,SAAK,YAAY,WAAW;AAE5B,UAAM,YAAY,eAAe,IAAI,KAAK,UAAU,GAAG,MAAM;AAC7D,SAAK,UAAU,SAAS;AAExB,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC3C,WAAK,SAAS,CAAC,IAAI,eAAe,IAAI,KAAK,SAAS,CAAC,GAAG,MAAM;AAAA,IAClE;AAAA,EACJ;AAAA,EAES,OAAO,QAAe;AAC3B,SAAK,SAAS,MAAM;AAEpB,UAAM,cAAc,KAAK,sBAAsB;AAC/C,SAAK,WAAW;AAEhB,SAAK,SAAS,CAAC;AAAA,EACnB;AAAA,EAES,KAAK,MAAc,SAA+B;AACvD,QAAI,KAAK,UAAU,EAAG;AACtB,QAAI,KAAK,QAAQ,MAAM,EAAG;AAE1B,UAAM,gBAAgB,eAAe,qBAAqB,MAAM,OAAO;AACvE,UAAM,oBAAoB,eAAe,IAAI,KAAK,kBAAkB,GAAG,aAAa;AACpF,SAAK,kBAAkB,iBAAiB;AAExC,UAAM,cAAc,eAAe,IAAI,KAAK,YAAY,GAAG,eAAe,qBAAqB,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAC9H,SAAK,YAAY,WAAW;AAE5B,UAAM,YAAY,eAAe,IAAI,KAAK,UAAU,GAAG,eAAe,qBAAqB,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAC1H,SAAK,UAAU,SAAS;AAExB,UAAM,WAAW,KAAK,SAAS,IAAI,KAAK,mBAAmB,IAAI;AAC/D,SAAK,SAAS,QAAQ;AAEtB,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC3C,WAAK,SAAS,CAAC,IAAI,eAAe,IAAI,KAAK,SAAS,CAAC,GAAG,eAAe,qBAAqB,MAAM,KAAK,kBAAkB,CAAC,CAAC;AAAA,IAC/H;AAEA,SAAK,SAAS,eAAe,IAAI;AAAA,EACrC;AAEJ;;;ACrfA,IAAM,OAAgC;AAAA,EAClC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACP;AAEA,SAAS,iBAAiB,WAAW,CAAC,UAAU;AAC5C,MAAI,MAAM,OAAO,MAAM;AACnB,SAAK,MAAM,GAAG,IAAI;AAAA,EACtB;AACJ,CAAC;AAED,SAAS,iBAAiB,SAAS,CAAC,UAAU;AAC1C,MAAI,MAAM,OAAO,MAAM;AACnB,SAAK,MAAM,GAAG,IAAI;AAAA,EACtB;AACJ,CAAC;AAEM,SAAS,qBAAqB,MAAkB,eAAuB,iBAAyB,KAAK;AACxG,MAAI,KAAK;AACT,MAAI,KAAK;AAET,MAAI,KAAK,EAAG,OAAM;AAClB,MAAI,KAAK,EAAG,OAAM;AAClB,MAAI,KAAK,EAAG,OAAM;AAClB,MAAI,KAAK,EAAG,OAAM;AAElB,MAAI,OAAO,KAAK,OAAO,GAAG;AACtB,UAAM,iBAAiB,eAAe,UAAU,IAAI,eAAe,IAAI,EAAE,CAAC;AAC1E,UAAM,QAAQ,eAAe,qBAAqB,gBAAgB,cAAc;AAEhF,SAAK,WAAW,KAAK;AAAA,EACzB;AACJ;;;AClBO,IAAM,mBAAN,MAAuB;AAAA,EAC1B,OAAO,WAAW,GAAiC,GAA2C;AAC1F,QAAG,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,KAAK,EAAE,IAAI,GAAG;AACrF,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAc,YAAY,OAAmB,OAAiD;AAC1F,QAAG,iBAAiB,oBAAoB,iBAAiB,kBAAiB;AACtE,aAAO,KAAK,iBAAiB,OAAO,KAAK;AAAA,IAC7C;AAEA,QAAG,iBAAiB,iBAAiB,iBAAiB,eAAc;AAChE,aAAO,KAAK,kBAAkB,OAAO,KAAK;AAAA,IAC9C;AAEA,QAAG,iBAAiB,oBAAoB,iBAAiB,eAAc;AACnE,aAAO,KAAK,uBAAuB,OAAO,KAAK;AAAA,IACnD;AAEA,QAAG,iBAAiB,iBAAiB,iBAAiB,kBAAiB;AACnE,aAAO,KAAK,uBAAuB,OAAO,KAAK;AAAA,IACnD;AAAA,EACJ;AAAA,EAEA,OAAO,eAAe,OAAmB,OAAmB,QAA8B;AACtF,QAAI,eAAe,MAAM,UAAU,IAAI,IAAK,IAAI,MAAM,QAAQ;AAC9D,QAAI,eAAe,MAAM,UAAU,IAAI,IAAK,IAAI,MAAM,QAAQ;AAE9D,QAAI,cAAc,KAAK,IAAI,MAAM,eAAe,GAAG,MAAM,eAAe,CAAC;AACzE,QAAI,mBAAmB,eAAe,WAAW,MAAM,kBAAkB,GAAG,MAAM,kBAAkB,CAAC;AAErG,QAAI,eAAe,WAAW,kBAAkB,MAAM,IAAI,EAAG;AAE7D,QAAI,mBAAmB,EAAE,IAAI,eAAe,eAAe,WAAW,kBAAkB,MAAM;AAC9F,QAAI,qBAAqB,eAAe;AAExC,QAAI,uBAAuB,EAAG;AAE9B,QAAI,aAAa,mBAAmB;AACpC,QAAI,UAAU,eAAe,qBAAqB,YAAY,MAAM;AAEpE,UAAM,qBAAqB,eAAe;AAAA,MACtC,MAAM,kBAAkB;AAAA,MACxB,eAAe,qBAAqB,CAAC,cAAc,OAAO;AAAA,IAC9D;AAEA,UAAM,qBAAqB,eAAe;AAAA,MACtC,MAAM,kBAAkB;AAAA,MACxB,eAAe,qBAAqB,cAAc,OAAO;AAAA,IAC7D;AAEA,UAAM,kBAAkB,kBAAkB;AAC1C,UAAM,kBAAkB,kBAAkB;AAAA,EAC9C;AAAA,EAEA,OAAO,2BAA2B,SAAwC;AACtE,UAAM,EAAE,OAAO,OAAO,OAAO,IAAI;AAEjC,UAAM,eAAe,MAAM,UAAU,IAAI,IAAK,IAAI,MAAM,QAAQ;AAChE,UAAM,eAAe,MAAM,UAAU,IAAI,IAAK,IAAI,MAAM,QAAQ;AAEhE,UAAM,cAAc,KAAK,IAAI,MAAM,eAAe,GAAG,MAAM,eAAe,CAAC;AAE3E,UAAM,kBAAmB,MAAM,WAAW,MAAM,IAAK,IAAK,IAAI,MAAM,WAAW;AAC/E,UAAM,kBAAmB,MAAM,WAAW,MAAM,IAAK,IAAK,IAAI,MAAM,WAAW;AAE/E,QAAI,cAAc,QAAQ;AAC1B,QAAI,cAAc,CAAC;AACnB,QAAI,SAAS,CAAC;AACd,QAAI,SAAS,CAAC;AAEd,aAAQ,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAI;AACvC,kBAAY,CAAC,IAAI,eAAe;AAChC,aAAO,CAAC,IAAI,eAAe;AAC3B,aAAO,CAAC,IAAI,eAAe;AAAA,IAC/B;AAEA,aAAQ,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAI;AACvC,YAAM,KAAK,eAAe,WAAW,YAAY,CAAC,GAAG,MAAM,UAAU,CAAC;AACtE,YAAM,KAAK,eAAe,WAAW,YAAY,CAAC,GAAG,MAAM,UAAU,CAAC;AAEtE,aAAO,CAAC,IAAI;AACZ,aAAO,CAAC,IAAI;AAEZ,YAAM,SAAS,IAAI,eAAe,CAAC,GAAG,GAAG,GAAG,CAAC;AAC7C,YAAM,SAAS,IAAI,eAAe,CAAC,GAAG,GAAG,GAAG,CAAC;AAE7C,YAAM,yBAAyB,eAAe,qBAAqB,MAAM,mBAAmB,GAAG,MAAM;AACrG,YAAM,yBAAyB,eAAe,qBAAqB,MAAM,mBAAmB,GAAG,MAAM;AAErG,YAAM,mBAAmB,eAAe;AAAA,QACpC,eAAe,IAAI,MAAM,kBAAkB,GAAG,sBAAsB;AAAA,QACpE,eAAe,IAAI,MAAM,kBAAkB,GAAG,sBAAsB;AAAA,MACxE;AAEA,YAAM,qBAAqB,eAAe,WAAW,kBAAkB,MAAM;AAE7E,UAAI,KAAK,IAAI,kBAAkB,IAAI,KAAQ;AAE3C,YAAM,aAAa,eAAe,WAAW,QAAQ,MAAM;AAC3D,YAAM,aAAa,eAAe,WAAW,QAAQ,MAAM;AAE3D,YAAM,qBAAqB,eAAe,eACrC,aAAa,aAAc,kBAC3B,aAAa,aAAc;AAEhC,YAAM,mBAAmB,EAAE,IAAI,eAAe;AAE9C,YAAM,aAAc,mBAAmB;AACvC,YAAM,UAAU,eAAe,qBAAqB,YAAY,MAAM;AAEtE,kBAAY,CAAC,IAAI;AAAA,IACrB;AAEA,aAAQ,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AACxC,YAAM,UAAU,YAAY,CAAC;AAC7B,YAAM,KAAK,OAAO,CAAC;AACnB,YAAM,KAAK,OAAO,CAAC;AAEnB,YAAM,qBAAqB,eAAe;AAAA,QACtC,MAAM,kBAAkB;AAAA,QACxB,eAAe,qBAAqB,CAAC,cAAc,OAAO;AAAA,MAC9D;AACA,YAAM,kBAAkB,kBAAkB;AAE1C,YAAM,qBAAqB,eAAe;AAAA,QACtC,MAAM,kBAAkB;AAAA,QACxB,eAAe,qBAAqB,cAAc,OAAO;AAAA,MAC7D;AACA,YAAM,kBAAkB,kBAAkB;AAE1C,YAAM,sBAAsB,MAAM,mBAAmB,IAAI,eAAe,aAAa,IAAI,OAAO,IAAI;AACpG,YAAM,mBAAmB,mBAAmB;AAE5C,YAAM,sBAAsB,MAAM,mBAAmB,IAAI,eAAe,aAAa,IAAI,OAAO,IAAI;AACpG,YAAM,mBAAmB,mBAAmB;AAAA,IAChD;AAAA,EACJ;AAAA,EAEA,OAAO,eAAe,OAAmB,OAAkB,QAAwB,OAAc;AAC7F,QAAI,MAAM,UAAU,KAAK,MAAM,UAAU,GAAG;AACxC;AAAA,IACJ;AAAC;AAED,QAAI,MAAM,UAAU,GAAG;AACnB,YAAM,KAAK,eAAe,qBAAqB,OAAO,MAAM,CAAC;AAAA,IACjE,WAAW,MAAM,UAAU,GAAG;AAC1B,YAAM,KAAK,eAAe,qBAAqB,CAAC,OAAO,MAAM,CAAC;AAAA,IAClE,OAAO;AACH,UAAI,YAAY,QAAQ;AACxB,YAAM,KAAK,eAAe,qBAAqB,CAAC,WAAW,MAAM,CAAC;AAClE,YAAM,KAAK,eAAe,qBAAqB,WAAW,MAAM,CAAC;AAAA,IACrE;AAAA,EACJ;AAAA,EAEA,OAAO,kBAAkB,UAAyB,UAAuD;AACrG,UAAM,YAA8B,SAAS,YAAY;AACzD,UAAM,YAA8B,SAAS,YAAY;AAEzD,QAAI,SAAyB,eAAe;AAC5C,QAAI,QAAgB,OAAO;AAE3B,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,YAAM,UAA0B,UAAU,CAAC;AAC3C,YAAM,UAA0B,WAAW,IAAI,KAAK,UAAU,MAAM;AACpE,YAAM,OAAuB,eAAe,WAAW,SAAS,OAAO;AAEvE,UAAI,OAAuB,IAAI,eAAe,KAAK,IAAI,IAAI,KAAK,CAAC;AACjE,aAAO,eAAe,UAAU,IAAI;AAEpC,YAAM,QAAQ,KAAK,gBAAgB,WAAW,IAAI;AAClD,YAAM,QAAQ,KAAK,gBAAgB,WAAW,IAAI;AAElD,UAAG,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,KAChD;AACI;AAAA,MACJ;AAEA,YAAM,YAAoB,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,GAAG;AAE/E,UAAG,YAAY,OAAO;AAClB,gBAAQ;AACR,iBAAS;AAAA,MACb;AAAA,IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,YAAM,UAA0B,UAAU,CAAC;AAC3C,YAAM,UAA0B,WAAW,IAAI,KAAK,UAAU,MAAM;AACpE,YAAM,OAAuB,eAAe,WAAW,SAAS,OAAO;AAEvE,UAAI,OAAuB,IAAI,eAAe,KAAK,IAAI,IAAI,KAAK,CAAC;AACjE,aAAO,eAAe,UAAU,IAAI;AAEpC,YAAM,QAAQ,KAAK,gBAAgB,WAAW,IAAI;AAClD,YAAM,QAAQ,KAAK,gBAAgB,WAAW,IAAI;AAElD,UAAI,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,KAAI;AACjD;AAAA,MACJ;AAEA,YAAM,YAAoB,KAAK,IAAI,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,MAAM,GAAG;AAE/E,UAAG,YAAY,OAAO;AAClB,gBAAQ;AACR,iBAAS;AAAA,MACb;AAAA,IACJ;AAEA,QAAI,YAA4B,eAAe,WAAW,SAAS,UAAU,GAAG,SAAS,UAAU,CAAC;AAEpG,QAAG,eAAe,WAAW,WAAW,MAAM,IAAI,GAAE;AAChD,eAAS,eAAe,qBAAqB,IAAI,MAAM;AAAA,IAC3D;AAEA,UAAM,gBAAgB,KAAK,2BAA2B,UAAU,QAAQ;AAExE,UAAM,UAA4B;AAAA,MAC9B,OAAO;AAAA,MACP,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,2BAA2B,UAAyB,UAA2C;AAClG,QAAI,gBAAwB,OAAO;AACnC,QAAI,gBAAkC,CAAC;AACvC,UAAM,UAAU;AAEhB,UAAM,eAAe,CAAC,eAA8B,kBAAiC;AACjF,eAAS,IAAI,GAAG,IAAI,cAAc,YAAY,EAAE,QAAQ,KAAK;AACzD,cAAM,QAAQ,cAAc,YAAY,EAAE,CAAC;AAE3C,iBAAS,IAAI,GAAG,IAAI,cAAc,YAAY,EAAE,QAAQ,KAAK;AACzD,gBAAM,gBAAgB,cAAc,YAAY,EAAE,CAAC;AACnD,gBAAM,aAAa,cAAc,YAAY,GAAG,IAAI,KAAK,cAAc,YAAY,EAAE,MAAM;AAC3F,gBAAM,UAAU,IAAI,QAAQ,eAAe,UAAU;AAErD,gBAAM,EAAE,cAAc,WAAW,IAAI,KAAK,yBAAyB,OAAO,OAAO;AAEjF,cAAI,aAAa,gBAAgB,SAAS;AACtC,4BAAgB;AAChB,4BAAgB,CAAC,YAAY;AAAA,UACjC,WAAW,KAAK,IAAI,aAAa,aAAa,IAAI,SAAS;AACvD,0BAAc,KAAK,YAAY;AAAA,UACnC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,iBAAa,UAAU,QAAQ;AAC/B,iBAAa,UAAU,QAAQ;AAE/B,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,uBAAuB,QAA0B,SAAsD;AAE1G,UAAM,WAA6B,QAAQ,YAAY;AAEvD,QAAI,SAAyB,eAAe;AAC5C,QAAI,QAAgB,OAAO;AAE3B,QAAI,OAAuB,eAAe;AAC1C,UAAM,UAAU;AAEhB,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAM,UAA0B,SAAS,CAAC;AAC1C,YAAM,UAA0B,UAAU,IAAI,KAAK,SAAS,MAAM;AAClE,YAAM,OAAuB,eAAe,WAAW,SAAS,OAAO;AAEvE,UAAI,KAAK,aAAa,IAAI,QAAS;AAEnC,aAAO,eAAe,UAAU,IAAI,eAAe,KAAK,IAAI,IAAI,KAAK,CAAC,CAAC;AAEvE,YAAM,EAAE,KAAKC,OAAM,KAAKC,MAAK,IAAI,KAAK,gBAAgB,UAAU,IAAI;AACpE,YAAM,EAAE,KAAKC,OAAM,KAAKC,MAAK,IAAI,KAAK,cAAc,QAAQ,IAAI;AAEhE,UAAIH,QAAOG,QAAO,WAAWD,QAAOD,QAAO,SAAS;AAChD;AAAA,MACJ;AAEA,YAAMG,aAAoB,KAAK,IAAID,QAAOH,OAAMC,QAAOC,KAAI;AAE3D,UAAGE,aAAY,OAAM;AACjB,gBAAQA;AACR,iBAAS;AAAA,MACb;AAAA,IACJ;AAEA,UAAM,mBAA2B,KAAK,qBAAqB,QAAQ,QAAQ;AAC3E,QAAI,qBAAqB,GAAI;AAE7B,UAAM,cAA8B,SAAS,gBAAgB;AAE7D,WAAO,eAAe,UAAU,eAAe,WAAW,aAAa,OAAO,YAAY,CAAC,CAAC;AAE5F,UAAM,EAAE,KAAK,MAAM,KAAK,KAAK,IAAI,KAAK,gBAAgB,UAAU,IAAI;AACpE,UAAM,EAAE,KAAK,MAAM,KAAK,KAAK,IAAI,KAAK,cAAc,QAAQ,IAAI;AAEhE,QAAI,OAAO,OAAO,WAAW,OAAO,OAAO,SAAS;AAChD;AAAA,IACJ;AAEA,UAAM,YAAoB,KAAK,IAAI,OAAO,MAAM,OAAO,IAAI;AAE3D,QAAG,YAAY,OAAM;AACjB,cAAQ;AACR,eAAS;AAAA,IACb;AAEA,UAAM,YAAY,OAAO,aAAa;AAEtC,QAAI,YAAY,QAAS;AAEzB,YAAQ,QAAQ;AAChB,aAAS,eAAe,UAAU,MAAM;AAExC,QAAI,CAAC,QAAQ,UAAU,KAAK,CAAC,OAAO,YAAY,EAAG;AAEnD,QAAI,YAA4B,eAAe,WAAW,QAAQ,UAAU,GAAG,OAAO,YAAY,CAAC;AAEnG,QAAI,UAAU,aAAa,IAAI,QAAS;AAExC,QAAG,eAAe,WAAW,WAAW,MAAM,IAAI,GAAE;AAChD,eAAS,eAAe,qBAAqB,IAAI,MAAM;AAAA,IAC3D;AAEA,QAAI,UAA0B,eAAe;AAC7C,QAAI,gBAAwB,OAAO;AAEnC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAM,UAA0B,SAAS,CAAC;AAC1C,YAAM,UAA0B,UAAU,IAAI,KAAK,SAAS,MAAM;AAClE,YAAM,UAAmB,IAAI,QAAQ,SAAS,OAAO;AAErD,YAAM,EAAE,YAAY,aAAa,IAAI,KAAK,yBAAyB,OAAO,YAAY,GAAG,OAAO;AAEhG,UAAI,aAAa,eAAe;AAC5B,wBAAgB;AAChB,kBAAU;AAAA,MACd;AAAA,IACJ;AAEA,UAAM,UAA4B;AAAA,MAC9B,OAAO;AAAA,MACP,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA,eAAe,CAAC,OAAO;AAAA,IAC3B;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,iBAAiB,SAA2B,SAAyD;AACxG,QAAI,SAAyB,eAAe;AAC5C,QAAI,QAAgB;AAEpB,QAAI,WAAmB,eAAe,SAAS,QAAQ,YAAY,GAAG,QAAQ,YAAY,CAAC;AAC3F,QAAI,QAAgB,QAAQ,UAAU,IAAI,QAAQ,UAAU;AAE5D,QAAG,YAAY,OAAM;AACjB;AAAA,IACJ;AAEA,QAAI,eAA+B,eAAe;AAAA,MAC9C,QAAQ,YAAY;AAAA,MACpB,eAAe;AAAA,QACX,QAAQ,UAAU;AAAA,QAClB,eAAe,UAAU,eAAe,WAAW,QAAQ,YAAY,GAAG,QAAQ,YAAY,CAAC,CAAC;AAAA,MAAC;AAAA,IACrG;AAGJ,aAAS,eAAe,UAAU,eAAe,WAAW,QAAQ,YAAY,GAAG,QAAQ,YAAY,CAAC,CAAC;AACzG,YAAQ,QAAQ;AAEhB,UAAM,UAA4B;AAAA,MAC9B,OAAO;AAAA,MACP,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA,eAAe,CAAC,YAAY;AAAA,IAChC;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,yBAAyB,OAAuB,SAAwC;AAC3F,QAAI;AAEJ,UAAM,KAAqB,eAAe,WAAW,QAAQ,QAAQ,QAAQ,MAAM;AACnF,UAAM,KAAqB,eAAe,WAAW,OAAO,QAAQ,MAAM;AAE1E,UAAM,qBAA6B,GAAG,oBAAoB;AAE1D,QAAI,uBAAuB,GAAG;AAC1B,qBAAe,QAAQ;AAAA,IAC3B,OAAO;AACH,YAAM,aAAqB,eAAe,WAAW,IAAI,EAAE;AAC3D,YAAM,IAAY,aAAa;AAE/B,UAAI,KAAK,GAAG;AACR,uBAAe,QAAQ;AAAA,MAC3B,WAAW,KAAK,GAAG;AACf,uBAAe,QAAQ;AAAA,MAC3B,OAAO;AACH,uBAAe,eAAe;AAAA,UAC1B,QAAQ;AAAA,UACR,eAAe,qBAAqB,GAAG,EAAE;AAAA,QAC7C;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,kBAAkB,eAAe,gBAAgB,OAAO,YAAY;AAE1E,WAAO;AAAA,MACH,YAAY;AAAA,MACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,OAAO,gBAAgB,UAA4B,MAAoD;AACnG,QAAI,MAAM,OAAO;AACjB,QAAI,MAAM,OAAO;AAEjB,aAAQ,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAI;AACpC,YAAM,SAAyB,SAAS,CAAC;AACzC,YAAM,aAAqB,eAAe,WAAW,QAAQ,IAAI;AAEjE,UAAG,aAAa,KAAK;AAAE,cAAM;AAAA,MAAW;AACxC,UAAG,aAAa,KAAK;AAAE,cAAM;AAAA,MAAW;AAAA,IAC5C;AAEA,WAAO,EAAE,KAAK,IAAI;AAAA,EACtB;AAAA,EAEA,OAAO,cAAc,QAA0B,MAAoD;AAC/F,QAAI,YAA4B,eAAe,UAAU,IAAI;AAC7D,QAAI,kBAAkC,eAAe,qBAAqB,OAAO,UAAU,GAAG,SAAS;AAEvG,QAAI,SAAyB,eAAe,IAAI,OAAO,YAAY,GAAG,eAAe;AACrF,QAAI,SAAyB,eAAe,WAAW,OAAO,YAAY,GAAG,eAAe;AAE5F,UAAM,MAAc,KAAK,IAAI,eAAe,WAAW,QAAQ,IAAI,GAAG,eAAe,WAAW,QAAQ,IAAI,CAAC;AAC7G,UAAM,MAAc,KAAK,IAAI,eAAe,WAAW,QAAQ,IAAI,GAAG,eAAe,WAAW,QAAQ,IAAI,CAAC;AAE7G,WAAO,EAAE,KAAK,IAAI;AAAA,EACtB;AAAA,EAEA,OAAO,qBAAqB,QAA0B,UAAoC;AACtF,QAAI,SAAiB;AACrB,QAAI,cAAsB,OAAO;AAEjC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,YAAM,SAAyB,SAAS,CAAC;AACzC,YAAM,WAAmB,eAAe,SAAS,QAAQ,OAAO,YAAY,CAAC;AAE7E,UAAG,WAAW,aAAY;AACtB,sBAAc;AACd,iBAAS;AAAA,MACb;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AACJ;;;ACzeO,IAAM,0BAAN,MAA8B;AAAA,EAOjC,YAAY,OAAmB,OAAmB,QAAwB,OAAe,eAAgC;AACrH,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,gBAAgB;AAAA,EACzB;AACJ;;;ACRO,IAAM,gBAAN,MAAoB;AAAA,EAyDvB,YAAY,OAAe,QAAgB;AApD3C,wBAAuB;AAEvB,oBAAyB,CAAC;AAC1B,mBAA+B,oBAAI,IAAI;AACvC,mBAA0B,eAAe;AAEzC,uBAA4C,oBAAI,IAAI;AAEpD,SAAQ,eAAwB;AAChC,SAAQ,WAAoB;AAC5B,SAAQ,oBAA6B;AAErC,SAAQ,oBAAoD,CAAC;AAC7D,SAAQ,YAA8B,CAAC;AAwCnC,SAAK,QAAQ;AACb,SAAK,SAAS;AAEd,SAAK,SAAS,SAAS,cAAc,QAAQ;AAC7C,SAAK,OAAO,QAAQ,KAAK;AACzB,SAAK,OAAO,SAAS,KAAK;AAE1B,UAAM,MAAM,KAAK,OAAO,WAAW,IAAI;AAEvC,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,6CAA6C;AAAA,IACjE;AAEA,SAAK,UAAU;AACf,SAAK,WAAW,CAAC;AACjB,SAAK,QAAQ,MAAM;AAAA,EACvB;AAAA,EAtDA,gBAAgB,OAAe;AAC3B,SAAK,eAAe;AAAA,EACxB;AAAA,EAEA,kBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,YAAY,OAAe;AACvB,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,cAAa;AACT,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,YAAY,UAAgC;AACxC,SAAK,UAAU,KAAK,QAAQ;AAAA,EAChC;AAAA,EAEA,eAAe,UAAgC;AAC3C,UAAM,QAAQ,KAAK,UAAU,QAAQ,QAAQ;AAC7C,QAAI,SAAS,GAAG;AACZ,WAAK,UAAU,OAAO,OAAO,CAAC;AAAA,IAClC;AAAA,EACJ;AAAA,EAEA,gBAAgB,MAAwB;AACpC,aAAS,YAAY,KAAK,WAAW;AACjC,eAAS,OAAO,IAAI;AAAA,IACxB;AAAA,EACJ;AAAA,EAEA,iBAAiB,UAA4C;AACzD,SAAK,kBAAkB,KAAK,QAAQ;AAAA,EACxC;AAAA,EAqBA,YAA+B;AAC3B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,aAAuC;AACnC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,QAAQ,MAAwB;AAC5B,SAAK,SAAS,KAAK,IAAI;AACvB,SAAK,QAAQ,IAAI,KAAK,MAAM,GAAG,IAAI;AAAA,EACvC;AAAA,EAEA,WAAWC,KAAc;AACrB,SAAK,WAAW,KAAK,SAAS,OAAO,UAAQ,KAAK,MAAM,MAAMA,GAAE;AAChE,SAAK,QAAQ,OAAOA,GAAE;AAAA,EAC1B;AAAA,EAEA,QAAQA,KAAgC;AACpC,WAAO,KAAK,QAAQ,IAAIA,GAAE;AAAA,EAC9B;AAAA,EAEA,WAAW,QAAuB;AAC9B,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,gBAAsB;AAClB,0BAAsB,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAClD;AAAA,EAEQ,eAAe;AACnB,SAAK,QAAQ,UAAU,GAAG,GAAG,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM;AAAA,EACtE;AAAA,EAEQ,SAAS,WAAyB;AACtC,UAAM,iBAAiB,YAAY,KAAK,gBAAgB;AACxD,SAAK,eAAe;AAEpB,SAAK,aAAa;AAElB,UAAM,aAAa;AACnB,UAAM,cAAc,gBAAgB;AAGpC,aAAS,OAAO,GAAG,OAAO,YAAY,QAAQ;AAC1C,WAAK,aAAa,WAAW;AAC7B,WAAK,aAAa;AAClB,WAAK,iBAAiB;AAAA,IAC1B;AAEA,0BAAsB,KAAK,SAAS,KAAK,IAAI,CAAC;AAAA,EAClD;AAAA,EAEQ,aAAa,aAA2B;AAC5C,aAAS,QAAQ,KAAK,UAAU;AAC5B,iBAAW,YAAY,KAAK,mBAAmB;AAC3C,iBAAS,IAAI;AAAA,MACjB;AAEA,WAAK,KAAK,aAAa,KAAK,OAAO;AAAA,IACvC;AAAA,EACJ;AAAA,EAEQ,eAAc;AAClB,aAAS,QAAQ,KAAK,UAAU;AAC5B,WAAK,KAAK;AAEV,UAAG,KAAK,gBAAgB,KAAK,KAAK,YAAY,GAAE;AAC5C,cAAM,UAAU,KAAK,WAAW;AAEhC,YAAG,mBAAmB,0BAAyB;AAC3C,cAAI,SAAS,CAAC,KAAK,UAAU,CAAC;AAC9B,gBAAM,OAAO,KAAK,QAAQ;AAE1B,cAAG,KAAK,YAAY,KAAK,gBAAgB,8BAA6B;AAClE,mBAAO,KAAK,KAAK,GAAG;AACpB,mBAAO,KAAK,KAAK,GAAG;AAAA,UACxB;AAEA,sBAAY,WAAW,SAAS,MAAM;AAEtC,cAAG,gBAAgB,eAAc;AAC7B,wBAAY,WAAW,SAAS,KAAK,YAAY,CAAC;AAAA,UACtD;AAAA,QACJ;AAAA,MACJ;AAEA,WAAK,gBAAgB,IAAI;AAAA,IAC7B;AAAA,EACJ;AAAA,EAGQ,mBAAyB;AAC7B,SAAK,YAAY,MAAM;AAEvB,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,SAAS,GAAG,KAAK;AAC/C,YAAM,QAAQ,KAAK,SAAS,CAAC;AAC7B,YAAM,YAAY,MAAM,QAAQ;AAEhC,eAAS,IAAI,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC/C,cAAM,QAAQ,KAAK,SAAS,CAAC;AAC7B,cAAM,YAAY,MAAM,QAAQ;AAEhC,YAAI,qBAAqB,SAAS,qBAAqB,MAAO;AAC9D,YAAI,CAAC,iBAAiB,WAAW,WAAW,SAAS,EAAG;AAExD,cAAM,UAAwC,iBAAiB,YAAY,OAAO,KAAK;AAEvF,YAAI,SAAS;AACT,gBAAM,EAAE,OAAAC,QAAO,OAAAC,QAAO,QAAQ,OAAO,cAAc,IAAI;AAEvD,gBAAM,UAAmC,IAAI;AAAA,YACzCD;AAAA,YAAOC;AAAA,YAAO;AAAA,YAAQ;AAAA,YAAO;AAAA,UACjC;AAEA,eAAK,YAAY,IAAI,OAAO;AAAA,QAChC;AAAA,MACJ;AAAA,IACJ;AAEA,eAAW,WAAW,KAAK,aAAa;AACpC,YAAM,EAAE,OAAO,OAAO,QAAQ,OAAO,cAAc,IAAI;AAEvD,UAAG,KAAK,mBAAkB;AACtB,oBAAY,WAAW,KAAK,WAAW,GAAG,aAAa;AAAA,MAC3D;AAEA,uBAAiB,eAAe,OAAO,OAAO,QAAQ,KAAK;AAC3D,uBAAiB,eAAe,OAAO,OAAO,MAAM;AAAA,IAExD;AAAA,EACJ;AACJ;;;ACnNO,IAAM,qBAAN,MAAmD;AAAA,EACtD,OAAO,MAAwB;AAAA,EAM/B;AACJ;",
  "names": ["ShapeType", "minA", "maxA", "minB", "maxB", "axisDepth", "id", "bodyA", "bodyB"]
}
